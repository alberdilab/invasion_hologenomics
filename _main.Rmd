---
title: "AlberdiLab | Romeo et al. 2024"
subtitle: "Study title to be added"
author:
  - Claudia Romeo^[University of Copenhagen, claudia.romeo@sund.ku.dk], [...], and Antton Alberdi^[University of Copenhagen, antton.alberdi@sund.ku.dk]
date: "Last update: `r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
url: https://alberdilab.github.io/invasion_hologenomics
description: |
  Data analysis code for the study of metagenomeâ€‘assembled genomes and derived microbial communities from faecal samples of invasive and native squirrel species.
link-citations: yes
github-repo: alberdilab/invasion_hologenomics
---

```{r knitr_opts, echo=FALSE}
knitr::opts_chunk$set(
    class.source = "script-source",
    class.output = "script-output",
    comment = NA)
```

# Introduction

This webbook contains all the code used for the analysis of metagenomic data from invasive Sciurus carolinensis and native Sciurus vulgaris squirrels along urbanization gradients and across seasons.

## Prepare the R environment

### Environment

To reproduce all the analyses locally, clone this repository in your computer using:

```
RStudio > New Project > Version Control > Git
```

And indicating the following git repository:

> https://github.com/alberdilab/invasion_hologenomics.git

Once the R project has been created, follow the instructions and code chunks shown in this webbook.

### Libraries

The following R packages are required for the data analysis.

```{r load_libraries, warning=FALSE, comments="", message=FALSE}

# Base
library(R.utils)
library(knitr)
library(tidyverse)
library(devtools)
library(tinytable)

# For tree handling
library(ape)
library(phyloseq)
library(phytools)

# For plotting
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggnewscale)
library(gridExtra)
library(ggtreeExtra)
library(ggtree)
library(ggh4x)
library(mapproj)
library(RColorBrewer)
library(reshape2)
library(ggResidpanel)

# For statistics
# library(spaa)
library(vegan)
library(Rtsne)
#library(geiger)
library(hilldiv2)
library(distillR)
library(broom.mixed)
library(gtsummary)
library(lmerTest)
library(lme4)
library(lmerTest)
library(emmeans)
library(effects)
library(car)
library(Hmsc)
library(corrplot)

```

<!--chapter:end:index.Rmd-->

# Data preparation

#### Read counts
This is the document containing the number of sequencing reads from each sample have been mapped to each MAG. Note that this is the raw data that needs to be further processed before running any statistics on them.

```{r load_count, message=FALSE}
read_counts <- read.csv("data/squirrels_counts.csv", sep=";") %>%
  rename(genome = 1)
```

Generate a vector of genome names to be employed for filtering and sorting data in downstream steps.
```{r genome_list, message=FALSE}
genomes <- read_counts$genome # create list of genome names
```

#### Genome coverage
Proportion of each genome covered by sequencing reads.

```{r genome_coverage, message=FALSE}
genome_coverage <- read.csv("data/squirrels_coverage.csv", sep=";") %>%
  rename(genome = 1) 
```

#### Sample metadata

```{r sample_metadata, message=FALSE}
sample_metadata <- read.csv("data/squirrels_metadata.csv",sep=";",header=T)
sample_metadata <- sample_metadata %>%  filter(!is.na(sampleID))
```

#### Genome metadata

```{r genome_metadata, message=FALSE}
genome_metadata <- read.csv("data/squirrels_mag_info.csv",sep=";") %>%
    rename(length=mag_size)
```

#### Coverage filtering
Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. 

```{r filter_coverage}
min_coverage=0.3
read_counts_filt <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>%
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) 
```

#### Generate genome count table
After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information.

```{r calc_genometable}
readlength=150 #change if sequencing read length is different
genome_counts <- read_counts_filt %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) )) %>%
  select_if(~!all(. == 0)) #remove samples with no MAGs
```

#### Genome tree

```{r load_tree, message=FALSE, warning=FALSE}
genome_tree <- read.tree("data/squirrels.tree")
```

#### MAG functional annotations
These are the raw annotation table generated by DRAM, which are used to generate GIFT data using either distillR or KEGG.
```{r genome_annotations, message=FALSE}
genome_gifts <- read.csv("data/squirrels_distillr.csv", sep=";") 

genome_kegg <- read.csv("data/squirrels_merged_kegg.csv", sep=";")
```

#### Colour palette
```{r colour_palette}

ehi_phylum_colors <- read.table("data/ehi_phylum_colors.tsv",sep="\t",header=T,comment.char = "")
# Arrange colors alphabetically
colors_alphabetic <- ehi_phylum_colors %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(phylum, colors) %>%
  unique() %>%
  arrange(phylum) %>%
  select(colors) %>%
  pull()
```

#### Wrap working objects
In the last step, the objects that are needed for downstream analyses are stored in an R object.

```{r wrap_objects}
save(read_counts, read_counts_filt, genome_counts, genome_tree, genome_metadata, genome_gifts, genome_kegg, sample_metadata, ehi_phylum_colors, colors_alphabetic, file = "data/squirrels_data.Rdata")
```

<!--chapter:end:00-data_preparation.Rmd-->

# Data Summary

```{r load_datasets01, include=TRUE}
rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
```

## Sample summary

Summary of sampled individuals and analysed faecal samples.

```{r sample_description, message=FALSE}

#number of samples
length(sample_metadata$sample)

#number of samples by species
sample_metadata %>%
  group_by(species) %>%
  summarise(n_samples = length(sample)) %>%
  tt()

#number of samples by species and sex
sample_metadata %>%
  group_by(species, sex) %>%
  summarise(n_samples = length(sample)) %>%
  tt()

#number of samples by species and development
sample_metadata %>%
  group_by(species, development) %>%
  summarise(n_samples = length(sample)) %>%
  tt()

#number of samples by species and type of area
sample_metadata %>%
  group_by(species,area_type) %>%
  summarise(n_samples = length(sample)) %>%
  tt()

#number of distinct squirrels
n_distinct(sample_metadata$animal)

#number of squirrels by species and type of area
sample_metadata %>%
  group_by(species,area_type) %>%
  summarise(distinct_squirrels = n_distinct(animal)) %>%
  tt()

#number of squirrels by species and season
sample_metadata %>%
  group_by(species,season) %>%
  summarise(distinct_squirrels = n_distinct(animal)) %>%
  tt()

#n of analysed faecal samples
ncol(read_counts)

```

Geographical location of sampled red squirrel (light blue) and grey squirrel (pink) populations in Italy.

```{r map, warning=FALSE}
#Summarise for generating map
options(dplyr.summarise.inform = FALSE)
sample_metadata_summary <- sample_metadata %>%
  #Group by geography and count samples
  select(sample, latitude, longitude, country, species) %>%
  group_by(latitude, longitude, species) %>%
  summarize(count = n()) %>%
  ungroup()

italy <- map_data("world", region="italy") %>%
  summarise(long = mean(long), lat = mean(lat))

#plotting on map
sample_metadata_summary %>%
  ggplot(.) +
  #render map
  geom_map(
    data=map_data("world", region="italy"),
    map = map_data("world", region="italy"),
    aes(long, lat, map_id=region),
    color = "white", fill = "#cccccc", linewidth = 0.2
  ) +
  #render points
  geom_point(
    aes(x=longitude,y=latitude, color=species),
    alpha=0.5, shape=16) +
  #add general plot layout
  theme_minimal() +
  theme(legend.position = "none",
        axis.title.x=element_blank(),
        axis.title.y=element_blank()
  ) + coord_map("mercator")
```


```{r summary_table, include=FALSE}
#summary table
sample_metadata %>%
  select(sample,species,sample_type,country,latitude,longitude) %>%
  tt()

```

## Sequencing data summary

Total amount of sequencing data generated from the analysed samples.

```{r sequencing_summary}

#amount of discarded data (GB)
sum(round(((sample_metadata$metagenomic_bases+sample_metadata$host_bases)/
             (1-sample_metadata$bases_lost_fastp_percent))-
            (sample_metadata$metagenomic_bases+sample_metadata$host_bases)))/1000000000

#amount of host data (GB)
sum(sample_metadata$host_bases)/1000000000

#amount of metagenomic data (GB)
sum(sample_metadata$metagenomic_bases)/1000000000

#amount of estimated prokaryotic data (singleM)
sum(sample_metadata$metagenomic_bases * sample_metadata$singlem_fraction)/1000000000

```


Origin of DNA sequences obtained from each sample.

```{r sequence_origin}
sequence_fractions <- read_counts %>%
  pivot_longer(-genome, names_to = "sample", values_to = "value") %>%
  group_by(sample) %>%
  summarise(mags = sum(value)) %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %>%
  mutate(mags_bases = mags*146) %>%
  mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %>%
  mutate(unmapped_bases = metagenomic_bases - mags_bases) %>%
  mutate(unmapped_bases = ifelse(unmapped_bases < 0, 0, unmapped_bases)) %>%
  select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases)

mags_bases_mean <- sequence_fractions %>%
  mutate(mags_bases = mags_bases / 1000000000) %>%
  select(mags_bases) %>%
  pull() %>%
  mean()

sequence_fractions %>%
  pivot_longer(!sample, names_to = "fraction", values_to = "value") %>%
  mutate(value = value / 1000000000) %>%
  mutate(fraction = factor(fraction, levels = c("lowqual_bases","host_bases","unmapped_bases","mags_bases"))) %>%
  ggplot(., aes(x = sample, y = value, fill=fraction)) +
  geom_bar(position="stack", stat = "identity") +
  scale_fill_manual(values=c("#CCCCCC","#178a94","#ee8080","#d03161")) +
  geom_hline(yintercept = mags_bases_mean, linetype = "dashed", color = "black") +
  labs(x = "Samples", y = "Amount of data (GB)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = "bottom")

```

Sequencing assessment: difference between mapping rate and estimated singleM proportion

```{r seq_assessment, warning=FALSE}
# Estimated vs mapped prokaryotic fraction
sequence_fractions <- read_counts %>%
  pivot_longer(-genome, names_to = "sample", values_to = "value") %>%
  group_by(sample) %>%
  summarise(mags = sum(value)) %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %>%
  mutate(mags_bases = mags*146) %>%
  mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %>%
  mutate(unmapped_bases = metagenomic_bases - mags_bases) %>%
  mutate(unmapped_bases = ifelse(unmapped_bases < 0, 0, unmapped_bases)) %>%
  select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases)

singlem_table <- sequence_fractions %>%
  mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  mutate(singlem_proportion = round(singlem_fraction*100,2)) %>%
  select(sample,mags_proportion,singlem_proportion) %>%
  mutate(mags_proportion = ifelse(singlem_proportion == 0, 0, mags_proportion)) %>% #convert zeros to NA
  mutate(singlem_proportion = ifelse(singlem_proportion == 0, NA, singlem_proportion)) %>% #convert zeros to NA
  mutate(singlem_proportion = ifelse(singlem_proportion < mags_proportion, NA, singlem_proportion)) %>% #if singlem is smaller, then NA, to simplify plot
  mutate(singlem_proportion = ifelse(singlem_proportion > 100, 100, singlem_proportion)) #simplify


singlem_table %>%
  pivot_longer(!sample, names_to = "proportion", values_to = "value") %>%
  mutate(proportion = factor(proportion, levels = c("mags_proportion","singlem_proportion"))) %>%
  ggplot(., aes(x = value, y = sample, color=proportion)) +
  geom_line(aes(group = sample), color = "#f8a538") +
  geom_point() +
  scale_color_manual(values=c("#52e1e8","#876b53")) +
  theme_classic() +
  labs(y = "Samples", x = "Prokaryotic fraction (%)") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = "right")

# Export difference b/w mags and singlem proportions to be used later in script 05-diversity_models
singlem <- sequence_fractions %>%
  mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  mutate(singlem_proportion = round(singlem_fraction*100,2)) %>%
  mutate(mags_singlem = mags_proportion/singlem_proportion) %>%
  mutate(est_mapp = ifelse(mags_singlem >= 1, 1, mags_singlem)) %>%
  select(sample,mags_singlem,est_mapp)

write.table(singlem, file = "data/singlem.csv", row.names = FALSE, dec = ".", sep = ";", 
              quote = FALSE)

```


## MAGs summary

```{r mags_summary}

#number of MAGs
nrow(read_counts)

#number of MAGs without species-level annotation (i.e., "new species")
genome_metadata %>%
  filter(species == "s__") %>%
  nrow()

#number of phylums
genome_metadata %>%
  select(phylum) %>%
  unique() %>%
  pull() %>%
  length()

```



<!--chapter:end:01-data_summary.Rmd-->

# MAGs overview

```{r load_datasets02, include=TRUE}
rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
```


## MAGs phylogeny


```{r mags_philogeny, fig.height=8, fig.width=10, fig.fullwidth=TRUE, warning=FALSE, message=FALSE}

# Which phylum the MAG belongs to
phyla <- ehi_phylum_colors %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(phylum, colors) %>%
  unique()

# What is the genome size of the MAG in MBs (megabases)
lengths <- genome_metadata %>%
  select(c(genome,length)) %>%
  mutate(length=round(length/1000000,2))

# What is the completeness of the MAG
mag_completeness <- genome_metadata %>%
  select(c(genome,completeness)) %>%
  as.data.frame() %>%
  remove_rownames() %>%
  column_to_rownames(var = "genome")


# Generate the phylum color heatmap
phylum_heatmap <- ehi_phylum_colors %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(genome,phylum) %>%
  mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
  column_to_rownames(var = "genome")

# Create baseline circular genome tree
circular_tree <- force.ultrametric(genome_tree,method="extend") %>%
  ggtree(., layout = 'circular', size = 0.1, angle=45) +
  xlim(-1, NA)

# Add phylum colors ring
circular_tree <- gheatmap(circular_tree, phylum_heatmap, offset=0.05, width=0.3, colnames=FALSE) +
  scale_fill_manual(values=colors_alphabetic, name="Phylum") +
  #geom_tiplab2(size=1, hjust=-0.1) +
  theme(legend.position = "right", plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0))

# Flush color scale to enable a new color scheme in the next ring
circular_tree <- circular_tree + new_scale_fill()

# Add completeness ring
circular_tree <-  circular_tree +
  #new_scale_fill() +
  scale_fill_gradient(low = "#d1f4ba", high = "#f4baba", name="Genome\ncontamination") +
  geom_fruit(
    data=genome_metadata,
    geom=geom_bar,
    mapping = aes(x=completeness, y=genome, fill=contamination),
    offset = 0.55,
    orientation="y",
    stat="identity")

# Add genome-size ring
circular_tree <-  circular_tree +
  #new_scale_fill() +
  scale_fill_manual(values = "#cccccc") +
  geom_fruit(
    data=lengths,
    geom=geom_bar,
    mapping = aes(x=length, y=genome),
    offset = 0.05,
    orientation="y",
    stat="identity")


#Plot circular tree
circular_tree

```



## Genome quality

```{r quality_stats}
genome_metadata$completeness %>% mean()
genome_metadata$completeness %>% sd()
genome_metadata$contamination %>% mean()
genome_metadata$contamination %>% sd()
```


```{r quality_biplot, fig.width=9}

#create input table from original genome table
genome_details <- genome_metadata %>%
  select(c(genome,domain,phylum,completeness,contamination,length)) %>%
  mutate(length=round(length/1000000,2)) %>% #change length to MBs
  rename(comp=completeness,cont=contamination,size=length) %>% #rename columns
  remove_rownames() %>%
  arrange(match(genome, rev(genome_tree$tip.label))) #sort MAGs according to phylogenetic tree

#generate genome quality biplot
genome_stats_biplot <- genome_details %>%
  ggplot(aes(x=comp,y=cont,size=size,color=phylum)) +
  geom_point(alpha=0.7) +
  ylim(c(10,0)) +
  scale_color_manual(values=colors_alphabetic) +
  labs(y= "Contamination", x = "Completeness") +
  theme_classic() +
  theme(legend.position = "none")

#generate contamination boxplot
genome_stats_cont <- genome_details %>%
  ggplot(aes(y=cont)) +
  ylim(c(10,0)) +
  geom_boxplot(colour = "#999999", fill="#cccccc") +
  theme_void() +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = unit(c(0, 0, 0.40, 0),"inches")) #add bottom-margin (top, right, bottom, left)

#generate completeness boxplot
genome_stats_comp <-genome_details %>%
  ggplot(aes(x=comp)) +
  xlim(c(50,100)) +
  geom_boxplot(colour = "#999999", fill="#cccccc") +
  theme_void() +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = unit(c(0, 0, 0, 0.50),"inches")) #add left-margin (top, right, bottom, left)

#create composite figure
grid.arrange(grobs = list(genome_stats_comp,genome_stats_biplot,genome_stats_cont),
             layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3),
                                   c(2,2,2,2,2,2,2,2,2,2,2,3)))
```

## Functional attributes of MAGs


```{r func_attributes, fig.dim = c(10, 8), fig.fullwidth=TRUE, warning=FALSE, message=FALSE} 


#Generate a basal utrametric tree for the sake of visualisation
gift_tree <- force.ultrametric(genome_tree,method="extend") %>%
   ggtree(., size = 0.3)

#Add phylum colors next to the tree tips
gift_tree <- gheatmap(gift_tree, phylum_heatmap, offset=0, width=0.1, colnames=FALSE, color=NA) +
   scale_fill_manual(values=colors_alphabetic) +
    labs(fill="Phylum")

#Reset fill scale to use a different colour profile in the heatmap
gift_tree <- gift_tree + new_scale_fill()

gift_table <- genome_gifts %>%
  column_to_rownames(var="genome")

#Add functions heatmap
gift_tree <- gheatmap(gift_tree, gift_table, offset=0.5, width=3.5, colnames=FALSE, color=NA) +
  vexpand(.08) +
  coord_cartesian(clip = "off") +
  scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white")+
  labs(fill="GIFT")

#Reset fill scale to use a different colour profile in the heatmap
gift_tree <- gift_tree + new_scale_fill()

# Add completeness barplots
gift_tree <- gift_tree +
            geom_fruit(data=genome_metadata,
            geom=geom_bar,
            #grid.params=list(axis="x", text.size=2, nbreak = 1),
            axis.params=list(vline=TRUE),
            mapping = aes(x=length, y=genome, fill=completeness),
                 offset = 3.8,
                 orientation="y",
                 stat="identity") +
            scale_fill_gradient(low = "#cf8888", high = "#a2cc87") +
            labs(fill="Genome\ncompleteness")

#Plot combined tree + heatmap
gift_tree +
  theme(legend.position='right')

```



## Functional ordination of MAGs (distillr)

```{r, fig.width=10}

distillr_table <- genome_gifts %>%
  column_to_rownames(var="genome")

# Generate the tSNE ordination
tSNE_func2 <- Rtsne(X=distillr_table, dims = 2, check_duplicates = FALSE)

# Plot the ordination
tSNE_func2$Y %>%
  as.data.frame() %>%
  mutate(genome=rownames(distillr_table)) %>%
  inner_join(genome_metadata, by="genome") %>%
  rename(tSNE1="V1", tSNE2="V2") %>%
  select(genome,phylum,tSNE1,tSNE2, completeness) %>%
  ggplot(aes(x = tSNE1, y = tSNE2, color = phylum, size=completeness))+
  geom_point(shape=16, alpha=0.7) +
  scale_color_manual(values=colors_alphabetic) +
  theme_minimal() +
  theme(legend.position = "right")
```



<!--chapter:end:02-MAGs_overview.Rmd-->

# Community composition

```{r load_datasets03, include=TRUE}
rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
```

## Count data preparation

```{r data_preparation03, warning=FALSE}

genome_counts_log <- genome_counts %>% 
    column_to_rownames(var="genome") %>%
    mutate_all(~log10(.+1)) #fixed: mutate_at(vars(), ~log10(.+1))) was not working

genome_counts_pivot <- genome_counts %>%
  mutate_at(vars(-genome),~./sum(.)) %>% #apply TSS normalisation
  pivot_longer(-genome, names_to = "sample", values_to = "count") %>% #reduce to minimum number of columns
  left_join(., genome_metadata, by = join_by(genome == genome)) %>% #append taxonomy
  mutate(phylum = fct_relevel(phylum, rev(ehi_phylum_colors$phylum))) #sort phyla by taxonomy

genome_counts_by_host <- sample_metadata %>%
  select("sample","species","area_type", "development") %>%
  rename(host_sp=species) %>%
  left_join(genome_counts_pivot,., by=join_by("sample" == "sample")) #%>%
  #mutate(sample=factor(sample, levels = sample_sort)) #alternative to join: sorting by area_type

# Retrieve taxonomy colors to use standardised EHI colors
phylum_colors <- ehi_phylum_colors %>%
  filter(phylum %in% unique(genome_counts_by_host$phylum)) %>%
  select(colors) %>%
  pull() %>%
  rev()
phylum_colors <- c(phylum_colors,"#cccccc") #REMOVE! ONLY FOR ARCHAEANS
  
  
# Which host species each genome can be found in
genomes_by_species <- genome_counts_by_host %>%
  filter(count>0) %>%
  group_by(genome) %>%
  mutate(host = if_else(all(host_sp == "Sciurus vulgaris"), "only red",
                        if_else(all(host_sp == "Sciurus carolinensis"), "only grey", "both"))) %>%
  select(genome, host) %>%
  distinct(genome, .keep_all = TRUE) %>%
  left_join(.,genome_metadata, by='genome')

genomes_by_species$host <-factor(genomes_by_species$host, levels = c("both", "only red", "only grey"))


```

```{r mags_by_species03, fig.height=8, fig.width=10, fig.fullwidth=TRUE}

# Which phylum the MAG belongs to
phyla <- ehi_phylum_colors %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(phylum, colors) %>%
  unique()

# Generate the phylum color heatmap
phylum_heatmap <- ehi_phylum_colors %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(genome,phylum) %>%
  mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
  column_to_rownames(var = "genome")

# Create baseline circular genome tree
circular_tree <- force.ultrametric(genome_tree,method="extend") %>%
  ggtree(., layout = 'circular', size = 0.1, angle=45) +
  xlim(-1, NA)

# Add phylum colors ring
circular_tree <- gheatmap(circular_tree, phylum_heatmap, offset=0.05, width=0.2, colnames=FALSE) +
  scale_fill_manual(values=colors_alphabetic, name="Phylum") +
  #geom_tiplab2(size=1, hjust=-0.1) +
  theme(legend.position = "right", plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0))


#Flush color scale to enable a new color scheme in the next ring
circular_tree <- circular_tree + new_scale_fill()

# Add host ring
circular_tree_h <-  circular_tree +
  new_scale_fill() +
  scale_fill_manual(values = c("black", "#ed2939", "#92a0ad"), name="Host\nspecies") + #"#cc3333", "#999999"
  geom_fruit(
    data=genomes_by_species,
    geom=geom_tile,
    mapping = aes(y=genome, fill=host),
    offset = 0.55,
    width=0.2)
  

#Plot circular tree
circular_tree_h

```




```{r, fig.width=10, fig.fullwidth=TRUE}

vertical_tree <- force.ultrametric(genome_tree,method="extend") %>%
  ggtree(., size = 0.3)

#Add phylum colors
vertical_tree <- gheatmap(vertical_tree, phylum_heatmap, offset=0, width=0.1, colnames=FALSE, color=NA) +
  scale_fill_manual(values=colors_alphabetic)

#Reset fill scale
vertical_tree <- vertical_tree + new_scale_fill()

#Add counts
vertical_tree <- gheatmap(vertical_tree, genome_counts_log, offset=0.5, width=3.5, color=NA, colnames=FALSE) + #, colnames_angle=90, font.size=2, colnames_position="top", colnames_offset_y = 9
  vexpand(.08) +
  coord_cartesian(clip = "off") +
  scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white")

#Plot tree
vertical_tree +
  theme(legend.position='right')
```



## Taxonomic composition of samples


```{r taxonomic_composition_by_host, fig.width=10, fig.fullwidth=TRUE}

# sample_sort <- sample_metadata %>%
#   arrange(Area_type) %>%
#   select(sample) %>%
#   pull()

####TAXONOMIC COMPOSITION####


# Plot stacked barplot
ggplot(genome_counts_by_host, aes(x=sample,y=count,fill=phylum, group=phylum))+ #grouping enables keeping the same sorting of taxonomic units
  geom_bar(stat="identity", colour="white", linewidth=0.02)+ #plot stacked bars with white borders
  scale_fill_manual(values=phylum_colors, name="Phylum") +
  labs(y = "Relative abundance") +
  guides(fill = guide_legend(ncol = 1)) +
  facet_nested(~host_sp, scales="free", space="free") +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(linewidth = 0.5, linetype = "solid", colour = "black"),
        legend.position="right",
        )
```

```{r, fig.width=10, fig.fullwidth=TRUE}
phylum_summary <- genome_counts_by_host %>%
  group_by(sample,host_sp,phylum) %>%
  summarise(relabun=sum(count))

phylum_summary %>%
    group_by(phylum) %>%
    summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) 

phylum_arrange <- phylum_summary %>%
    group_by(phylum) %>%
    summarise(mean=mean(relabun)) %>%
    arrange(-mean) %>%
    select(phylum) %>%
    pull()

phylum_summary %>%
    filter(phylum %in% phylum_arrange) %>%
    mutate(phylum=factor(phylum,levels=rev(phylum_arrange))) %>%
    ggplot(aes(x=relabun, y=phylum, group=phylum, color=phylum)) +
        scale_color_manual(values=phylum_colors[rev(phylum_arrange)], name="Phylum") +
        geom_jitter(alpha=0.5) + 
        facet_nested(~host_sp, scales="free", space="free") +
        theme_minimal() + 
        theme(legend.position="right") +
        labs(y="Phylum",x="Relative abundance")

```
```{r, fig.width=10, fig.fullwidth=TRUE}
family_summary <- genome_counts_by_host %>%
  group_by(sample,host_sp,family) %>%
  summarise(relabun=sum(count))

family_summary %>%
    group_by(family) %>%
    summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) %>%
    arrange(-mean)

family_arrange <- family_summary %>%
    group_by(family) %>%
    summarise(mean=sum(relabun)) %>%
    arrange(-mean) %>%
    select(family) %>%
    pull()

family_summary %>%
    left_join(genome_metadata %>% select(family,phylum) %>% unique(),by=join_by(family==family)) %>%
    left_join(sample_metadata,by=join_by(sample==sample)) %>%
    filter(family %in% family_arrange[1:20]) %>%
    mutate(family=factor(family,levels=rev(family_arrange[1:20]))) %>%
    filter(relabun > 0) %>%
    ggplot(aes(x=relabun, y=family, group=family, color=phylum)) +
        scale_color_manual(values=colors_alphabetic) +
        geom_jitter(alpha=0.5) + 
        facet_grid(.~host_sp)+
        theme_minimal() + 
        labs(y="Family", x="Relative abundance", color="Phylum")
```
```{r, fig.width=10, fig.fullwidth=TRUE}
genus_summary <- genome_counts_by_host %>%
  group_by(sample,host_sp,genus) %>%
  summarise(relabun=sum(count))

genus_summary %>%
    group_by(genus) %>%
    summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) %>%
    arrange(-mean)

genus_arrange <- genus_summary %>%
    group_by(genus) %>%
    summarise(mean=sum(relabun)) %>%
    arrange(-mean) %>%
    select(genus) %>%
    pull()

genus_summary %>%
    left_join(genome_metadata %>% select(genus,phylum) %>% unique(),by=join_by(genus==genus)) %>%
    left_join(sample_metadata,by=join_by(sample==sample)) %>%
    filter(genus %in% genus_arrange[1:20]) %>%
    mutate(genus=factor(genus,levels=rev(genus_arrange[1:20]))) %>%
    filter(relabun > 0) %>%
    ggplot(aes(x=relabun, y=genus, group=genus, color=phylum)) +
        scale_color_manual(values=colors_alphabetic) +
        geom_jitter(alpha=0.5) + 
        facet_grid(.~host_sp)+
        theme_minimal() + 
        labs(y="Genus", x="Relative abundance", color="Phylum")
```

<!--chapter:end:03-community_composition.Rmd-->

# Diversity analyses

```{r load_datasets04, include=FALSE, include=TRUE, message=FALSE, warning=FALSE}

rm(list=ls()) #clear environment

load("data/squirrels_data.Rdata")
singlem <- read.csv("data/singlem.csv",sep=";",header=T)
options(contrasts = c('contr.sum','contr.poly'))

```

## Data preparation

```{r data_preparation04, message=FALSE}

#Change genome names column to row names
genome_counts <- genome_counts %>%
  column_to_rownames(var="genome")
genome_gifts <- genome_gifts %>%
  column_to_rownames(var="genome")

#Get list of present MAGs
present_MAGs <- genome_counts %>%
  filter(rowSums(.[, -1]) != 0) %>%
  rownames()

#Remove samples with all zeros (no data after filtering)
genome_counts_filt <- genome_counts %>%
  select_if(~!all(. == 0))

#Align distillr annotations with present MAGs and remove all-zero and all-one traits
present_MAGs <- present_MAGs[present_MAGs %in% rownames(genome_gifts)]

genome_gifts_filt <- genome_gifts[present_MAGs,] %>%
  select_if(~!all(. == 0)) %>%  #remove all-zero modules
  select_if(~!all(. == 1)) #remove all-one modules

#Align tree with present MAGs
tree_filt <- keep.tip(genome_tree,present_MAGs)

#Filter count table to only contain present MAGs after gifts filtering
genome_counts_filt <- genome_counts[present_MAGs,]

#Calculate sequence fractions for each samples
sequence_fractions <- read_counts %>%
  pivot_longer(-genome, names_to = "sample", values_to = "value") %>%
  group_by(sample) %>%
  dplyr::summarize(mags = sum(value)) %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %>%
  mutate(mags_bases = mags*146) %>%
  mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %>%
  mutate(unmapped_bases = metagenomic_bases - mags_bases) %>%
  mutate(unmapped_bases = ifelse(unmapped_bases < 0, 0, unmapped_bases)) %>%
  select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases)


```

## Alpha Diversity metrics 

```{r alpha_diversity}
#ALPHA DIVERSITY
q0n <- hilldiv2::hilldiv(genome_counts,q=0) %>% c()
q1n <- hilldiv2::hilldiv(genome_counts,q=1) %>% c()
q1p <- hilldiv2::hilldiv(genome_counts,q=1,tree=genome_tree) %>% c()
dist <- hilldiv2::traits2dist(genome_gifts_filt, method="gower")
q1f <- hilldiv2::hilldiv(genome_counts_filt,q=1,dist=dist) %>% c()

```

```{r alpha_summary, warning=FALSE}

# Merge all metrics
alpha_div <- cbind(sample=colnames(genome_counts),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3),func=round(q1f,3)) %>%
  as.data.frame()
columns <- c("richness","neutral","phylo","func", "mapped","total")

# Add amount of sequencing data to the table
alpha_div <- alpha_div %>%
  left_join(sequence_fractions, by = join_by(sample == sample)) %>% #add sequencing depth information
  mutate(mapped=round(mags_bases/1000000000,3)) %>% #modify depth to million reads
  mutate(total=round((mags_bases+unmapped_bases+host_bases+lowqual_bases)/1000000000,3)) %>%
  select(sample,richness,neutral,phylo,func,mapped,total) %>%
  mutate(across(-1, as.numeric))

squirrel_colors <- c("#999999", "#cc3333")

alpha_div %>%
  left_join(sample_metadata, by='sample') %>%
  select(sample, species, richness, neutral,phylo,func, mapped, total) %>%
  mutate(species = factor(species), # Convert to factor if necessary
        sample = factor(sample, levels = unique(sample)[order(species)])) %>%
  pivot_longer(-c(sample, species), names_to = "data", values_to = "value") %>%
  mutate(data = factor(data, levels = columns)) %>%
  ggplot(aes(x=value, y=sample, fill=species)) +
  geom_bar(stat='identity') +
  scale_fill_manual(values=squirrel_colors) +
  facet_wrap(~ data, scales="free_x", ncol=6) +
  #facet_grid(species ~ data, scales="free_x", space="fixed") +
  #force_panelsizes(ro#ws = 2, cols = 3, TRUE) +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    panel.grid.minor.x = element_line(size=.1, color="grey"),
    panel.spacing = unit(0, "lines"),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_blank(),
    legend.position = "none"
  )

# #table
# kable(alpha_div)

```

## Alpha Diversity comparisons

### By species and sex

```{r alpha_sex_plots, fig.dim = c(8, 10)}

squirrel_colors <- c("#999999", "#cc3333")

sex_colors <- c("turquoise3", "indianred2")


neutral.sex <- alpha_div %>%
            select(sample,neutral) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "sex", fill="white", add="jitter") +
                  scale_color_manual(values=sex_colors) +
                  scale_fill_manual(values=paste0(squirrel_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Neutral Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())

phylo.sex <- alpha_div %>%
            select(sample,phylo) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "sex", fill="white", add="jitter") +
                  scale_color_manual(values=sex_colors) +
                  scale_fill_manual(values=paste0(squirrel_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Phylogenetic Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())

func.sex <- alpha_div %>%
            select(sample,func) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "sex", fill="white", add="jitter") +
                  scale_color_manual(values=sex_colors) +
                  scale_fill_manual(values=paste0(squirrel_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Functional Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())


sex.legend <- get_legend(neutral.sex)


ggarrange(neutral.sex, phylo.sex, func.sex, #+ rremove("x.text"), 
          legend.grob = sex.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)
```


### By species and urbanisation

```{r alpha_urb_plots, fig.dim = c(8, 10)}

sample_metadata$area_type <-factor(sample_metadata$area_type, levels = c("rural", "suburban", "urban"))
area_colors <- c("#76b183","#d57d2c","#6b7398")

#neutral alpha by species*area_type
neutral.urb <- alpha_div %>%
            select(sample,neutral) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "area_type", fill="white", add="jitter") +
            scale_color_manual(values=area_colors) +
            scale_fill_manual(values=paste0(area_colors)) +
            stat_compare_means() +
            theme_classic() +
            labs(y = "Neutral Hill numbers") +
            theme(
              legend.position = "none",
              axis.title.x = element_blank()) +
            guides(color=guide_legend(title="Urbanisation"), fill="none")

#phylogenetic alpha by species*area_type
phylo.urb <- alpha_div %>%
            select(sample,phylo) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "area_type", fill="white", add="jitter") +
                  scale_color_manual(values=area_colors) +
                  scale_fill_manual(values=paste0(area_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Phylogenetic Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())

#functional (distillr-based) alpha by species*area_type
func.urb <- alpha_div %>%
            select(sample,func) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "area_type", fill="white", add="jitter") +
                  scale_color_manual(values=area_colors) +
                  scale_fill_manual(values=paste0(area_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Functional Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())


urb.legend <- get_legend(neutral.urb)


ggarrange(neutral.urb, phylo.urb, func.urb, #+ rremove("x.text"), 
          legend.grob = urb.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)
```



### By species and season

```{r alpha_season_plots, fig.dim = c(8, 10)}

sample_metadata$season <-factor(sample_metadata$season, levels = c("spring-summer", "autumn", "winter"))
season_colors <- c("#76b183","#e5bd5b","#6b7398")

#neutral alpha by species*season
neutral.seas <- alpha_div %>%
            select(sample,neutral) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "season", fill="white", add="jitter") +
            scale_color_manual(values=season_colors) +
            scale_fill_manual(values=paste0(season_colors)) +
            stat_compare_means() +
            theme_classic() +
            labs(y = "Neutral Hill numbers") +
            theme(
              legend.position = "none",
              axis.title.x = element_blank()) +
            guides(color=guide_legend(title="Season"), fill="none")

#phylogenetic alpha by species*season
phylo.seas <- alpha_div %>%
            select(sample,phylo) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "season", fill="white", add="jitter") +
                  scale_color_manual(values=season_colors) +
                  scale_fill_manual(values=paste0(season_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Phylogenetic Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())

#functional (distillr-based) alpha by species*season
func.seas <- alpha_div %>%
            select(sample,func) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "season", fill="white", add="jitter") +
                  scale_color_manual(values=season_colors) +
                  scale_fill_manual(values=paste0(season_colors)) +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Functional Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())


seas.legend <- get_legend(neutral.seas)


ggarrange(neutral.seas, phylo.seas, func.seas, #+ rremove("x.text"), 
          legend.grob = seas.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)

```


### By species and development

```{r alpha_dev_plots, fig.dim = c(8, 10)}

#neutral alpha by species*season
neutral.dev <- alpha_div %>%
            select(sample,neutral) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "development", fill="white", add="jitter") +
            stat_compare_means() +
            theme_classic() +
            labs(y = "Neutral Hill numbers") +
            theme(
              legend.position = "none",
              axis.title.x = element_blank()) +
            guides(color=guide_legend(title="Development"), fill="none")

#phylogenetic alpha by species*season
phylo.dev <- alpha_div %>%
            select(sample,phylo) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "development", fill="white", add="jitter") +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Phylogenetic Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())

#functional (distillr-based) alpha by species*season
func.dev <- alpha_div %>%
            select(sample,func) %>%
            pivot_longer(-sample, names_to = "data", values_to = "value") %>%
            mutate(data = factor(data, levels = columns))   %>%
            left_join(sample_metadata, by = join_by(sample == sample)) %>%
            ggboxplot(., x = "species", y = "value", color = "development", fill="white", add="jitter") +
                  stat_compare_means() +
                  theme_classic() +
                  labs(y = "Functional Hill numbers") +
                  theme(
                      legend.position = "none",
                      axis.title.x = element_blank())


dev.legend <- get_legend(neutral.seas)


ggarrange(neutral.dev, phylo.dev, func.dev, #+ rremove("x.text"), 
          legend.grob = seas.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)


```


### Alpha diversity and sequencing effort

```{r alpha_sequencing, message=FALSE, warning=FALSE}

#sequencing effort and diversity
ggplot(alpha_div, aes(x=mapped,y=neutral,label=sample)) +
  geom_smooth(method='lm', formula= y~x, color='#e08dde', fill='#e08dde') +
  geom_point(alpha=0.5, color="#6c9ebc") +
  geom_label_repel(max.overlaps = 100, cex=0.7) +
  labs(x = "GBs mapped to MAGs", y = "Neutral diversity (effective number of MAGs)") +
  theme_classic() +
  theme(legend.position="none")
```


## Alpha diversity models

### Data preparation for GLMMs

```{r data_prep_models}
diversity.data <- alpha_div %>%
  left_join(sample_metadata, by = join_by(sample == sample)) %>%
  mutate(season=factor(season, levels = c("spring-summer", "autumn", "winter"))) %>%
  right_join(singlem, by = join_by(sample == sample)) %>%
  group_by(species) %>%
  mutate(index500_st = scale(index500, center=T, scale=T)[,1]) %>%
  ungroup() %>%
  filter(sample!="EHI02263") %>% #remove outlier
  filter(development=="Adult") #remove juveniles, nursing and pregnant females

#check whether a low domain-adjusted mapping rate (DAMR) is associated with low diversity estimates 
ggplot(diversity.data, aes(x=est_mapp, y=neutral)) +
  geom_point(size=3, alpha=0.5, color="#6c9ebc") +
  labs(x = "DAMR (mapping rate to MAG catalogue/singleM microbial fraction estimate)", y = "Neutral diversity (effective number of MAGs)") +
  theme_classic() +
  theme(legend.position="none")

diversity.data <- diversity.data %>%
  filter(mags_singlem > 0.8) #remove 5 samples with low DAMR

#str(diversity.data)

```

```{r var_distrib, eval=FALSE}

# check y distributions
plot(diversity.data$neutral)
hist(diversity.data$neutral, breaks=30)
d <- density(diversity.data$neutral)
plot(d)

plot(diversity.data$phylo)
hist(diversity.data$phylo, breaks=30)
d <- density(diversity.data$phylo)
plot(d)

plot(diversity.data$func)
hist(diversity.data$func, breaks=30)
d <- density(diversity.data$func)
plot(d)

```


### Bayesian models - neutral alpha

```{r neutral_brm, message=FALSE, warning=FALSE}

set.seed(123)
neutral.brm <-brm(neutral ~ species + index500 + season + 
            + species:index500 + species:season 
            + (1|animal) + (1|sampling_site), 
            data=diversity.data,
            family=gaussian(),
            chains = 3,
            iter = 3000, 
            warmup = 1000)

#assessing model fit
plot(neutral.brm) #pairs(neutral.brm)
#posterior predictive check
pp_check(neutral.brm)

summary(neutral.brm)
describe_posterior(neutral.brm)
plot(p_direction(neutral.brm), stack=FALSE)
#plot(model_parameters(neutral.brm, effects = "all", component = "conditional"))

plot(conditional_effects(neutral.brm, effects = "species"))


```


### Bayesian models - phylogenetic alpha

```{r phylo_brm}

set.seed(123)
phylo.brm <-brm(phylo ~ species + index500 + season + 
            + species:index500 + species:season 
            + (1|animal) + (1|sampling_site),
            data=diversity.data,
            family=gaussian(),
            chains = 3,
            iter = 3000, 
            warmup = 1000)



#assessing model fit
plot(phylo.brm) #pairs(phylo.brm)
#posterior predictive check
pp_check(phylo.brm)

summary(phylo.brm)
describe_posterior(phylo.brm)
plot(p_direction(phylo.brm), stack=FALSE)


#conditional_effects(phylo.brm)
plot(conditional_effects(phylo.brm, effects = "species:season"))


```


### Bayesian models - functional (distillr-based) alpha


```{r func_brm}

set.seed(123)
func.brm <-brm(func ~ species + index500 + season + 
            + species:index500 + species:season 
            + (1|animal),
            data=diversity.data,
            family=gaussian(),
            chains = 3,
            iter = 3000, 
            warmup = 1000)


#assessing model fit
plot(func.brm) #pairs(func.brm)
#posterior predictive check
pp_check(func.brm)

summary(func.brm)
describe_posterior(func.brm)
plot(p_direction(func.brm), stack=FALSE)


conditions <- data.frame(season = c('spring-summer', 'autumn', 'winter'))
plot(conditional_effects(func.brm, effects = "index500:species",
                         conditions = conditions))


```

## Neutral beta diversity

```{r beta_diversity04, message=FALSE, eval=TRUE}

#neutral beta div
beta_q1n <-hilldiv2::hillpair(genome_counts, q=1, metric="S")


```

```{r permanova_beta, eval=TRUE}

#neutral beta diversity PERMANOVA

sample_metadata_adonis <- sample_metadata %>%
  filter(sample %in% labels(beta_q1n)) %>%
  arrange(sample) %>%
  #mutate(location=paste0(round(longitude,2),"_",round(latitude,2))) %>%
  select(sample,species,sex,development,area_type,macroarea,season) %>%
  select_if(~ length(unique(.)) > 1) %>% #remove columns with all-identical values
  column_to_rownames(var = "sample") %>%
  as.data.frame()

adonis2(formula=beta_q1n ~ ., data=sample_metadata_adonis[labels(beta_q1n),], permutations=999) %>%
  as.matrix() %>%
  print()

```
### Beta diversity by species and urbanization

```{r nmds_beta_area, eval=TRUE, fig.width=10}

beta_q1n_nmds <- beta_q1n %>%
  metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %>%
  vegan::scores() %>%
  as_tibble(., rownames = "sample") %>%
  left_join(sample_metadata, by = join_by(sample == sample))

beta_q1n_nmds %>%
  group_by(species) %>%
  filter(sample !="EHI00420") %>% #remove outliers
  mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
  mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(., aes(x=NMDS1,y=NMDS2, color=area_type, shape=species, label=sample)) +
  scale_color_manual(values=area_colors) +
  geom_point(size=2.5) + #geom_text(hjust=2, vjust=0) +
  geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
  theme_classic() +
  theme(legend.position="right", legend.box="vertical") +
  guides(color=guide_legend(title="Species"), shape=guide_legend(title="Area type"))
```
### Beta diversity by species and season

```{r nmds_beta_season , eval=TRUE, fig.width=10}

beta_q1n_nmds %>%
  group_by(species) %>%
  filter(sample !="EHI00420") %>% #remove outliers
  mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
  mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(., aes(x=NMDS1,y=NMDS2, color=season, shape=species)) +
  scale_color_manual(values=season_colors) +
  geom_point(size=2.5) +
  geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
  theme_classic() +
  theme(legend.position="right", legend.box="vertical") +
  guides(color=guide_legend(title="Species"), shape=guide_legend(title="Season"))
```

### Beta diversity by species and sex

```{r nmds_beta_sex, fig.width=10}

beta_q1n_nmds %>%
  group_by(species) %>%
  filter(sample !="EHI00420") %>% #remove outliers
  mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
  mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(., aes(x=NMDS1,y=NMDS2, color=sex, shape=species)) +
  geom_point(size=2.5) +
  geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
  theme_classic() +
  theme(legend.position="right", legend.box="vertical") +
  guides(color=guide_legend(title="Species"), shape=guide_legend(title="Sex"))
```


### Beta diversity by species and development

```{r nmds_beta_development, fig.width=10}

beta_q1n_nmds %>%
  group_by(species) %>%
  filter(sample !="EHI00420") %>% #remove outliers
  mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
  mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(., aes(x=NMDS1,y=NMDS2, color=development, shape=species)) +
  geom_point(size=2.5) +
  geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
  theme_classic() +
  theme(legend.position="right", legend.box="vertical") +
  guides(color=guide_legend(title="Species"), shape=guide_legend(title="Development"))
```




<!--chapter:end:04-diversity_analysis.Rmd-->

# Functional analyses

```{r load_datasets05, include=FALSE}
rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
```

## Data preparation

```{r GIFTs_data_preparation, echo = T, results = 'hide', warning=FALSE, message=FALSE}

tss <- function(abund){sweep(abund, 2, colSums(abund), FUN="/")} 

genome_counts <- genome_counts %>%
  column_to_rownames(var="genome")
genome_kegg <- genome_kegg %>%
  column_to_rownames(var="genome")
genome_gifts <- genome_gifts %>%
  column_to_rownames(var="genome")

#Get list of present MAGs
present_MAGs <- genome_counts %>%
  filter(rowSums(.[, -1]) != 0) %>%
  rownames()

#Align distillr annotations with present MAGs and remove all-zero and all-one traits
present_MAGs <- present_MAGs[present_MAGs %in% rownames(genome_gifts)]
genome_gifts_filt <- genome_gifts[present_MAGs,] %>%
  select_if(~!all(. == 0)) %>%  #remove all-zero modules
  select_if(~!all(. == 1)) #remove all-one modules

GIFTs_elements <- genome_gifts_filt


#Aggregate element-level GIFTs into the function level
GIFTs_functions <- to.functions(GIFTs_elements,GIFT_db)

#Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs
GIFTs_domains <- to.domains(GIFTs_functions,GIFT_db)

#Get overall metabolic capacity indices per MAG (at the domain level)
rowMeans(GIFTs_functions) # averaged at the function level (each function is weighed equally)
rowMeans(GIFTs_domains) # averaged at the domain level (each domain is weighed equally)

#Get community-weighed average GIFTs per sample
# GIFTs_elements_community <- to.community(GIFTs_elements,genome_counts,GIFT_db)
# GIFTs_functions_community <- to.community(GIFTs_functions,genome_counts,GIFT_db)
# GIFTs_domains_community <- to.community(GIFTs_domains,genome_counts,GIFT_db)


GIFTs_elements_community <- genome_counts %>%
  tss() %>%
  to.community(GIFTs_elements,.,GIFT_db)

GIFTs_functions_community <- genome_counts %>%
  tss() %>%
  to.community(GIFTs_functions,.,GIFT_db)

GIFTs_domains_community <- genome_counts %>%
  tss() %>%
  to.community(GIFTs_domains,.,GIFT_db)

```


```{r GIFTs_MCI, echo = T, warning=FALSE, message=FALSE}

GIFTs_elements_community %>%
  rowMeans() %>%
  as_tibble(., rownames = "sample") %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  group_by(species) %>%
  summarise(MCI = mean(value), sd = sd(value))

GIFTs_functions_community %>%
  rowMeans() %>%
  as_tibble(., rownames = "sample") %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  group_by(species) %>%
  summarise(MCI = mean(value), sd = sd(value))

GIFTs_domains_community %>%
  rowMeans() %>%
  as_tibble(., rownames = "sample") %>%
  left_join(sample_metadata, by = join_by(sample == sample))  %>%
  group_by(species) %>%
  summarise(MCI = mean(value), sd = sd(value))

merge_gift <- GIFTs_domains_community %>% 
  as.data.frame() %>% 
  rownames_to_column(., "sample") %>% 
  merge(., sample_metadata, by="sample")


```

## Genome-specific GIFT profiles

```{r genome_level_GIFTs, warnings=F, fig.width=10, fig.height=10}

GIFTs_elements %>%
  as_tibble(., rownames = "MAG") %>%
  reshape2::melt() %>%
  rename(Code_element = variable, GIFT = value) %>%
  inner_join(GIFT_db,by="Code_element") %>%
  ggplot(., aes(x=Code_element, y=MAG, fill=GIFT, group=Function))+
    geom_tile()+
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_fill_gradientn(limits = c(0,1), colours=brewer.pal(7, "YlGnBu"))+
    facet_grid(. ~ Function, scales = "free", space = "free")+
    theme_grey(base_size=8)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90))

```



## Element-level community-averaged GIFT profiles 

```{r community_averaged_GIFTs, warnings=F, fig.width=10}
GIFTs_elements_community %>%
  reshape2::melt() %>%
  rename(sample = Var1, Code_element = Var2, GIFT = value) %>%
  left_join(sample_metadata, by = join_by(sample == sample)) %>%
  left_join(GIFT_db,by="Code_element") %>%
  ggplot(., aes(x=Code_element, y=sample, fill=GIFT))+
    geom_tile()+
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_fill_gradientn(colours=brewer.pal(7, "YlGnBu"))+
    theme_grey(base_size=8)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90)) +
  facet_wrap(~species, scales="free")
```

```{r nmds, echo=T, results='hide'}

GIFTs_elements_nmds <- GIFTs_elements_community %>%
  dist() %>%
  metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %>%
  vegan::scores() %>%
  as_tibble(., rownames = "sample") %>%
  left_join(sample_metadata, by = join_by(sample == sample))

```
```{r nmds_plot}

squirrel_colors <- c("#999999", "#cc3333")

GIFTs_elements_nmds %>%
  filter(!(sample=="EHI00420")) %>% #remove outlier
  group_by(species) %>% 
  mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %>%
  mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(., aes(x=NMDS1,y=NMDS2, color=species, shape=area_type, label=sample)) +
  scale_color_manual(values=squirrel_colors) +
  geom_point(size=2.5) + #geom_text(hjust=2, vjust=0) +
  geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) +
  theme_classic() +
  theme(legend.position="right", legend.box="vertical") +
  guides(color=guide_legend(title="Species"), shape=guide_legend(title="Area type")) 
```



## Function-level community-averaged GIFT profiles

```{r function_community_GIFTs, warning=FALSE, fig.width=10}
# sample_sort <- sample_table %>%
#   select(sample,species,Area_type) %>%
#   arrange(species,Area_type) %>%
#   pull()
   
GIFTs_functions_community %>%
  reshape2::melt() %>%
  rename(sample = Var1, Code_function = Var2, GIFT = value) %>%
  left_join(GIFT_db,by = join_by(Code_function == Code_function)) %>%
  left_join(sample_metadata, by = join_by(sample == sample)) %>%
  #mutate(sample=factor(Sample, levels = sample_sort)) %>%
  ggplot(., aes(x=Function, y=sample, fill=GIFT))+
    geom_tile()+
    scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_fill_gradientn(colours=brewer.pal(7, "YlGnBu"))+
    facet_grid(species~., scales="free") +
    theme_grey(base_size=8)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), strip.text.x = element_text(angle = 90))

# GIFTs_functions_community %>%
#     as.data.frame() %>%
#     rownames_to_column(var="sample") %>%
#     pivot_longer(!sample,names_to="trait",values_to="gift") %>%
#     left_join(sample_metadata, by = join_by(sample == sample)) %>%
#     ggplot(aes(x=trait,y=sample,fill=gift)) +
#         geom_tile(colour="white", size=0.2)+
#         scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
#         facet_grid(species ~ ., scales="free",space="free")

```


```{r}

# GIFTs_functions_community %>%
#     as.data.frame() %>%
#     rownames_to_column(var="sample") %>%
#     pivot_longer(!sample,names_to="trait",values_to="gift") %>%
#     left_join(sample_metadata, by = join_by(sample == sample)) %>%
#     ggplot(aes(x=trait,y=sample,fill=gift)) +
#         geom_tile(colour="white", size=0.2)+
#         scale_fill_gradientn(colours=rev(c("#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#ddf1da")))+
#         facet_grid(species ~ ., scales="free",space="free")

species.df <- sample_metadata %>%
  select(sample, species, animal)

GIFTs_functions_community_tt <- GIFTs_functions_community %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(., species.df, by = join_by(sample == sample)) %>%
  pivot_longer(-c(sample, species, animal), names_to = "trait", values_to = "value") %>%
  group_by(trait) %>%
  mutate(model_result = list(lmerTest::lmer(value ~ species + (1 | animal)))) %>%
  ungroup() %>%
  select(trait,model_result) %>%
  unique() %>%
  mutate(estimate = map_dbl(model_result, ~broom.mixed::tidy(.) %>% filter(term == "speciesSciuruscarolinensis") %>% pull(estimate))) %>%
  mutate(p_value = map_dbl(model_result, ~broom.mixed::tidy(.) %>% filter(term == "speciesSciuruscarolinensis") %>% pull(p.value))) %>%
  mutate(p_value_adj = p.adjust(p_value, method = "bonferroni")) %>%
  left_join(GIFT_db %>% select(Code_function,Function) %>% unique(),by=join_by(trait==Code_function)) %>%
  rename(id=trait,trait=Function) %>%
  select(id,trait, estimate, p_value_adj)

GIFTs_functions_community_tt %>% tt() |> 
      style_tt(
        i = which(GIFTs_functions_community_tt$estimate < 0 & GIFTs_functions_community_tt$p_value_adj < 0.05),
        background = "#E5D5B1") |> 
      style_tt(
        i = which(GIFTs_functions_community_tt$estimate > 0 & GIFTs_functions_community_tt$p_value_adj < 0.05),
        background = "#B7BCCE")



 GIFTs_functions_community %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(., species.df, by = join_by(sample == sample)) %>%
  pivot_longer(-c(sample, species), names_to = "trait", values_to = "value") %>%
  mutate(trait = case_when(
      trait %in% GIFT_db$Code_function ~ GIFT_db$Function[match(trait, GIFT_db$Code_function)], TRUE ~ trait)) %>%
  mutate(trait=factor(trait,levels=unique(GIFT_db$Function))) %>%
  ggplot(aes(x=value, y=species, group=species, fill=species, color=species)) +
    geom_boxplot() +
    scale_color_manual(name="species",
          breaks=c("Sciurus carolinensis","Sciurus vulgaris"),
          labels=c("Sciurus carolinensis","Sciurus vulgaris"),
          values=c("#999999", "#cc3333")) +
      scale_fill_manual(name="species",
          breaks=c("Sciurus carolinensis","Sciurus vulgaris"),
          labels=c("Sciurus carolinensis","Sciurus vulgaris"),
          values=c("#bfbfbf", "#db7070")) +
    facet_grid(trait ~ ., space="free", scales="free") +
              theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
              strip.text.y = element_text(angle = 0)) + 
        labs(y="Traits",x="Metabolic capacity index")


```

## Domain-level

```{r domain_plots, fig.dim=c(8,10)}


squirrel_colors <- c("#999999", "#cc3333")

#Biosynthesis by species
biosynth.species <- merge_gift %>%
  ggboxplot(., x = "species", y = "Biosynthesis", color = "species", fill="white", add="jitter") +
      scale_color_manual(values=squirrel_colors) +
      scale_fill_manual(values=paste0(squirrel_colors)) +
      stat_compare_means() +
      theme_classic() +
      labs(y = "Biosynthesis functions") +
      theme(
        legend.position = "none",
        axis.title.x = element_blank())

#Degradation by species
degradation.species <- merge_gift %>%
  ggboxplot(., x = "species", y = "Degradation", color = "species", fill="white", add="jitter") +
      scale_color_manual(values=squirrel_colors) +
      scale_fill_manual(values=paste0(squirrel_colors)) +
      stat_compare_means() +
      theme_classic() +
      labs(y = "Degradation functions") +
      theme(
        legend.position = "none",
        axis.title.x = element_blank())

#Structure by species
structure.species <- merge_gift %>%
  ggboxplot(., x = "species", y = "Structure", color = "species", fill="white", add="jitter") +
      scale_color_manual(values=squirrel_colors) +
      scale_fill_manual(values=paste0(squirrel_colors)) +
      stat_compare_means() +
      theme_classic() +
      labs(y = "Structural functions") +
      theme(
        legend.position = "none",
        axis.title.x = element_blank())

sp.legend <- get_legend(biosynth.species)


ggarrange(biosynth.species, degradation.species, structure.species, #+ rremove("x.text"), 
          legend.grob = sp.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)


### Differences in bacterial functional capacity
#grid.arrange(arrangeGrob(p1, p5,p3, p4, ncol = 2))

```

```{r domain_plots2, fig.dim=c(8, 10)}

merge_gift$area_type <-factor(merge_gift$area_type, levels = c("rural", "suburban", "urban"))
area_colors <- c("#76b183","#d57d2c","#6b7398")

#Biosynthesis by species*area_type
biosynth.area <- merge_gift %>%
  ggboxplot(., x = "species", y = "Biosynthesis", color = "area_type", fill="white", add="jitter") +
  scale_color_manual(values=area_colors) +
  scale_fill_manual(values=paste0(area_colors)) +
  stat_compare_means() +
  theme_classic() +
  labs(y = "Biosynthesis") +
  theme(
    legend.position = "top",
    legend.box = "horizontal",
    axis.title.x = element_blank()) +
  guides(color=guide_legend(title="Area type"), fill="none")

#Degradation by species*area_type
degradation.area <- merge_gift %>%
  ggboxplot(., x = "species", y = "Degradation", color = "area_type", fill="white", add="jitter") +
  scale_color_manual(values=area_colors) +
  scale_fill_manual(values=paste0(area_colors)) +
  stat_compare_means() +
  theme_classic() +
  labs(y = "Degradation") +
  theme(
    legend.position = "top",
    legend.box = "horizontal",
    axis.title.x = element_blank()) +
  guides(color=guide_legend(title="Area type"), fill="none")

#Structure by species*area_type
structure.area <- merge_gift %>%
  ggboxplot(., x = "species", y = "Structure", color = "area_type", fill="white", add="jitter") +
  scale_color_manual(values=area_colors) +
  scale_fill_manual(values=paste0(area_colors)) +
  stat_compare_means() +
  theme_classic() +
  labs(y = "Structure") +
  theme(
    legend.position = "top",
    legend.box = "horizontal",
    axis.title.x = element_blank()) +
  guides(color=guide_legend(title="Area type"), fill="none")

area.legend <- get_legend(biosynth.area)


ggarrange(biosynth.area, degradation.area, structure.area, #+ rremove("x.text"), 
          legend.grob = area.legend, legend="right", common.legend = TRUE,
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 3)

```



<!--chapter:end:05-functional_analysis.Rmd-->


# HMSC setup 

```{r load_data06}
rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
singlem <- read.csv("data/singlem.csv",sep=";",header=T)
```

## Prepare input for Hmsc

```{r subsetting, warning=FALSE, comments="", message=FALSE}
sample_metadata <- sample_metadata %>%
  right_join(singlem, by = join_by(sample == sample)) %>%
  filter(development=="Adult") %>% #remove juveniles, nursing and pregnant females
  filter(est_mapp>0.8) #remove 5 samples with low DAMR

selected_genomes0 <- sample_metadata %>%
  pull(sample)

# Subset by prevalence (present in more than 5 samples)
selected_genomes1 <- genome_counts %>%
    column_to_rownames(var="genome") %>%
    select(any_of(selected_genomes0)) %>% 
    filter(rowSums(across(starts_with("EHI")) != 0) >= 5) %>%
    rownames()

# Subset by minimum representation of 1% relative abundance in at least 5 samples
selected_genomes2 <- genome_counts %>%
    filter(genome %in% selected_genomes1) %>%
    column_to_rownames(var="genome") %>%
    hilldiv2::tss() %>%
    as.data.frame() %>%
    filter(rowSums(across(starts_with("EHI")) >= 0.01) >= 5) %>%
    rownames()


# Subset genome metadata
genome_metadata_subset <- genome_metadata %>%
    filter(genome %in% selected_genomes2)
```

```{r hmsc_input, warning=FALSE, comments="", message=FALSE}
# Random effects data (study design)
StudyDesign <- sample_metadata %>%
                    select(sample,animal,sampling_site) %>%
                    mutate(sampling_site = factor(sampling_site)) %>%
                    mutate(animal = factor(animal)) %>%
                    column_to_rownames("sample")

# Genome count table (quantitative community data)
YData <- read_counts  %>%
                    filter(genome %in% selected_genomes2) %>% #subset genomes
                    mutate(across(where(is.numeric), ~ . +1 )) %>% #add +1 pseudocount to remove zeros
                    mutate(across(where(is.numeric), ~ . / (genome_metadata_subset$length / 150) )) %>% #transform to genome counts
                    mutate(across(where(is.numeric), ~  log(.) )) %>% #log-transform
                    column_to_rownames("genome") %>%
                    select(all_of(row.names(StudyDesign))) %>%  #filter only faecal samples
                    as.data.frame() %>%
                    t() # transpose

# Fixed effects data (explanatory variables)
XData <- sample_metadata %>%
                    select(sample,species,index500,season) %>%
                    mutate(logseqdepth=read_counts %>% #total log-sequencing depth
                        select(all_of(row.names(StudyDesign))) %>%
                        colSums() %>%
                        log()
                    ) %>%
                    mutate(index500 = index500) %>%
                    mutate(species = factor(species, levels=c("Sciurus vulgaris","Sciurus carolinensis"))) %>%
                    mutate(season = factor(season, levels=c("spring-summer","autumn","winter"))) %>%
                    column_to_rownames("sample")


# Genome trait data
TrData <- genome_gifts %>%
                    filter(genome %in% selected_genomes2) %>% #subset genomes
                    arrange(match(genome, colnames(YData))) %>%
                    column_to_rownames(var="genome") %>%
                    to.functions(.,GIFT_db) %>%
                    as.data.frame()

# Genome phylogeny
PData <- genome_tree
```

## Define formulas of the Hmsc model

```{r hmsc_formulas, warning=FALSE, comments="", message=FALSE}

# Fixed effects formula 
XFormula1 = ~species + index500 + season + logseqdepth
XFormula2 = ~species + index500 + season + logseqdepth + species*index500 
XFormula3 = ~species + index500 + season + logseqdepth + species*season 
XFormula4 = ~species + index500 + season + logseqdepth + species*season + species*index500 

# Study design
rL.animal = HmscRandomLevel(units = levels(StudyDesign$animal))
rL.sampling_site = HmscRandomLevel(units = levels(StudyDesign$sampling_site))
```

## Define and Hmsc models
```{r hmsc_models, warning=FALSE, comments="", message=FALSE}
#Define models 
model.1a = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula1,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal),
         distr = "normal",
         YScale = TRUE)

model.1b = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula1,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal, "sampling_site"=rL.sampling_site),
         distr = "normal",
         YScale = TRUE)

model.2a = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula2,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal),
         distr = "normal",
         YScale = TRUE)

model.2b = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula2,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal, "sampling_site"=rL.sampling_site),
         distr = "normal",
         YScale = TRUE)

model.3a = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula3,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal),
         distr = "normal",
         YScale = TRUE)

model.3b = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula3,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal, "sampling_site"=rL.sampling_site),
         distr = "normal",
         YScale = TRUE)

model.4a = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula4,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal),
         distr = "normal",
         YScale = TRUE)

model.4b = Hmsc(Y=YData,
         XData = XData,
         XFormula = XFormula4,
         studyDesign = StudyDesign,
         phyloTree = PData,
         ranLevels = list("animal"=rL.animal, "sampling_site"=rL.sampling_site),
         distr = "normal",
         YScale = TRUE)

#Save list of models as an R object.
model_list = list(model.1a=model.1a,model.1b=model.1b,model.2a=model.2a,model.2b=model.2b,model.3a=model.3a,model.3b=model.3b, model.4a=model.4a,model.4b=model.4b)
if (!dir.exists("hmsc")){dir.create("hmsc")}
save(model_list, file = "hmsc/hmsc.Rdata")
```

Upload **hmsc/hmsc.Rdata** to the HPC respecting the directory structure.

## Define MCMC
```{r hmsc_mcmc, warning=FALSE, comments="", message=FALSE}
# How often to sample the MCMC
MCMC_samples_list = 250

# The number of MCMC steps between each recording sample
MCMC_thin_list = c(1, 10)

# The number of MCMC chains to use
nChains = 4
```


## Generate Hmsc executables

The next chunk generates shell files for every combination of model, MCMC samples and MCMM thinning, ready to be launched as SLURM jobs.

```{r hmsc_executables, warning=FALSE, comments="", message=FALSE, eval=FALSE}

modelchains <- expand.grid(model = names(model_list), sample = MCMC_samples_list, thin = MCMC_thin_list)

if (!dir.exists("hmsc")){dir.create("hmsc")}
for(i in c(1:nrow(modelchains))){
      modelname=as.character(modelchains[i,1])
      sample=modelchains[i,2]
      thin=modelchains[i,3]
      executablename <- paste0("hmsc/exe_",modelname,"_",sample,"_",thin,".sh")
      fitname <- paste0("hmsc/fit_",modelname,"_",sample,"_",thin,".Rdata")
      convname <- paste0("hmsc/conv_",modelname,"_",sample,"_",thin,".Rdata")
      model <- paste0('model_list$',modelname)
      psrf.beta.name <-  paste0("psrf.beta.",modelname,"_",sample,"_",thin)
      psrf.gamma.name <-  paste0("psrf.gamma.",modelname,"_",sample,"_",thin)
      psrf.rho.name <-  paste0("psrf.rho.",modelname,"_",sample,"_",thin)
      jobname <- paste0("hmsc_",modelname,"_",sample,"_",thin)
      minutes <- round(sample * thin * (ncol(YData)/50), 0)
      code <- sprintf("#!/bin/bash
#SBATCH --job-name=%s                   # Job name
#SBATCH --nodes=1
#SBATCH --ntasks=4                      # Run on 4 CPUs
#SBATCH --mail-user=antton.alberdi@sund.ku.dk
#SBATCH --mem=200gb                     # Job memory request
#SBATCH --time=%d                       # In minutes

# Activate conda environment
module load mamba/1.3.1
if ! conda info --envs | grep -q hmsc; then
  mamba create -p ./hmsc/hmsc_env -y r-essentials r-base r-tidyverse r-Hmsc
fi

# Activate conda environment
source activate ./hmsc/hmsc_env

# Run R script
Rscript -e '
library(tidyverse)
library(Hmsc)
# Load formulas and data
load(\"hmsc/hmsc.Rdata\")

# Declare placeholders
modelname = \"%s\"
model = %s
fitname = \"%s\"
convname = \"%s\"
sample = %d
thin = %d
nchains = %d

# Run model fitting
m = sampleMcmc(hM = model,
         samples = sample,
         thin = thin,
         adaptNf=rep(ceiling(0.4*sample*thin),model$nr),
         transient = ceiling(0.5*sample*thin),
         nChains = nchains,
         nParallel = nchains)

# Assess chain convergence
mpost = convertToCodaObject(m,
      spNamesNumbers = c(T,F),
      covNamesNumbers = c(T,F),
      Beta = TRUE,
      Gamma = TRUE,
      V = FALSE,
      Sigma = FALSE,
      Rho = TRUE,
      Eta = FALSE,
      Lambda = FALSE,
      Alpha = FALSE,
      Omega = FALSE,
      Psi = FALSE,
      Delta = FALSE) # Convert to CODA object

# Fixed effects
assign(paste0(\"psrf.beta.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Beta,multivariate=FALSE)$psrf)

# Traits
assign(paste0(\"psrf.gamma.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Gamma,multivariate=FALSE)$psrf)

# Phylogeny
assign(paste0(\"psrf.rho.\", modelname,\"_\",sample,\"_\",thin), gelman.diag(mpost$Rho,multivariate=FALSE)$psrf)

# Write convergence data
save(%s, %s, %s, file=convname)

# Save model fit object
save(m, file=fitname)
'
", jobname, minutes, modelname, model, fitname, convname, sample, thin, nChains, psrf.beta.name, psrf.gamma.name, psrf.rho.name)
      writeLines(code, executablename)
    }
```

Upload the produced **hmsc/exe_XXXXX.sh** files to the HPC respecting the directory structure.

## Fit Hmsc models (in Mjolnir HPC)

Launch the SLURM jobs by using:

```{sh, eval=FALSE}
# Submit all .sh files in the hmsc folder
for jobfile in hmsc/exe_*.sh; do
    sbatch "$jobfile"
done

#Or launch them one by one only the ones you want to launch
sbatch hmsc/exe_model1_250_10.sh
sbatch hmsc/exe_model2_250_10.sh
sbatch hmsc/exe_model3_250_10.sh
sbatch hmsc/exe_model4_250_10.sh

sbatch hmsc/exe_model5_250_1.sh
sbatch hmsc/exe_model6_250_10.sh
sbatch hmsc/exe_model7_250_10.sh
sbatch hmsc/exe_model8_250_10.sh
```

## Assess chain convergence

Convergence diagnostic values substantially above 1 indicate lack of convergence.
Values below 1.1 are considered good enough

```{r hmsc_convergence, warning=FALSE, comments="", message=FALSE, eval=FALSE}

# Load all conv file available in the hmsc folder
list.files(path = "hmsc", pattern = "^conv_", full.names = TRUE, include.dirs = TRUE) %>%
  lapply(.,load,.GlobalEnv)

# Create a merged psrf.beta (genome) plot
ls() %>%
        grep("^psrf\\.beta", ., value = TRUE) %>%
        map_dfr(~ {
         mat <- get(.x)
          data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %>%
              rownames_to_column(var="parameter") %>%
              mutate(model = str_split(modelchain, "_") %>% map_chr(1) %>% gsub("psrf.beta.","",.)) %>%
              mutate(sample = str_split(modelchain, "_") %>% map_chr(2)) %>% #extract sample info from model name
              mutate(thin = str_split(modelchain, "_") %>% map_chr(3)) #extract thin info from model name
      }) %>%
      ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) +
        geom_violin(fill="#b8d9e3", color="#328da8") +
        geom_jitter(alpha=0.3,size=0.2, color="#a8babf") +
        stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom="crossbar", width=0.2, color="orange") +
        geom_hline(yintercept=1.1, linetype="dashed", color = "red") +
        ylim(0.9,2)+
        labs(x="Model chains",y="Parameter estimates")+
        theme_classic()+
        coord_flip()

# Create a merged psrf.gamma (trait) plot
ls() %>%
        grep("^psrf\\.gamma", ., value = TRUE) %>%
        map_dfr(~ {
         mat <- get(.x)
          data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %>%
              rownames_to_column(var="parameter") %>%
              mutate(model = str_split(modelchain, "_") %>% map_chr(1) %>% gsub("psrf.gamma.","",.)) %>%
              mutate(sample = str_split(modelchain, "_") %>% map_chr(2)) %>% #extract sample info from model name
              mutate(thin = str_split(modelchain, "_") %>% map_chr(3)) #extract thin info from model name
      }) %>%
      ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) +
        geom_violin(fill="#b8d9e3", color="#328da8") +
        geom_jitter(alpha=0.3,size=0.2, color="#a8babf") +
        stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom="crossbar", width=0.2, color="orange") +
        geom_hline(yintercept=1.1, linetype="dashed", color = "red") +
        ylim(0.9,2)+
        labs(x="Model chains",y="Parameter estimates")+
        theme_classic()+
        coord_flip()


# Create a merged psrf.rho (phylogeny) plot
ls() %>%
        grep("^psrf\\.rho", ., value = TRUE) %>%
        map_dfr(~ {
         mat <- get(.x)
          data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %>%
              rownames_to_column(var="parameter") %>%
              mutate(model = str_split(modelchain, "_") %>% map_chr(1) %>% gsub("psrf.rho.","",.)) %>%
              mutate(sample = str_split(modelchain, "_") %>% map_chr(2)) %>% #extract sample info from model name
              mutate(thin = str_split(modelchain, "_") %>% map_chr(3)) #extract thin info from model name
      }) %>%
      ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) +
        geom_violin(fill="#b8d9e3", color="#328da8") +
        geom_jitter(alpha=0.3,size=0.2, color="#a8babf") +
        stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom="crossbar", width=0.2, color="orange") +
        geom_hline(yintercept=1.1, linetype="dashed", color = "red") +
        ylim(0.9,2)+
        labs(x="Model chains",y="Parameter estimates")+
        theme_classic()+
        coord_flip()

```

```{r model_fit, eval=FALSE}

# Select modelchain of interest
load("hmsc/fit_model.1a_250_10.Rdata")
m1a.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.1b_250_10.Rdata")
m1b.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.2a_250_10.Rdata")
m2a.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.2b_250_10.Rdata")
m2b.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.3a_250_10.Rdata")
m3a.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.3b_250_10.Rdata")
m3b.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.4a_250_10.Rdata")
m4a.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

load("hmsc/fit_model.4b_250_10.Rdata")
m4b.WAIC <- computeWAIC(m, ghN = 10, byColumn = TRUE) %>% sum()

WAICsum <- c(m1a.WAIC,m1b.WAIC,m2a.WAIC,m2b.WAIC,m3a.WAIC,m3b.WAIC,m4a.WAIC,m4b.WAIC) %>% rbind() 

print(WAICsum)
# print(WAICsum)
# print(WAICmedian)
```

<!--chapter:end:06-hmsc_setup.Rmd-->

# HMSC analysis

```{r load_data07}

rm(list=ls()) #clear environment
load("data/squirrels_data.Rdata")
```

## Model list

```{r hmsc_model_list}

# Select modelchain of interest
load("hmsc/fit_model.4a_250_10.Rdata")

levels.1a <- c("species","index500","season","logseqdepth","Random: animal")
levels.1b <- c("species","index500","season","logseqdepth","Random: animal", "Random: sampling_site")
levels.2a <- c("species","index500","season","species:index500","logseqdepth","Random: animal")
levels.2b <- c("species","index500","season","species:index500","logseqdepth","Random: animal", "Random: sampling_site")
levels.3a <- c("species","index500","season","species:season","logseqdepth","Random: animal")
levels.3b <- c("species","index500","season","species:season","logseqdepth","Random: animal", "Random: sampling_site")
levels.4a <- c("species","index500","season","species:index500","species:season","logseqdepth","Random: animal")
levels.4b <- c("species","index500","season","logseqdepth","species:index500","species:season","Random: animal", "Random: sampling_site")
```


## Compute variance partitioning

```{r hmsc_varpart, warning=FALSE, comments="", message=FALSE}
# Compute variance partitioning
varpart=computeVariancePartitioning(m)

varpart$vals %>%
   as.data.frame() %>%
   rownames_to_column(var="variable") %>%
   pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
   mutate(variable=factor(variable, levels=levels.4a)) %>%
   group_by(variable) %>%
   summarise(mean=mean(value)*100,sd=sd(value)*100) %>%
   tt()
```

```{r hmsc_varpart_plot, warning=FALSE, comments="", message=FALSE}
# Basal tree
varpart_tree <- genome_tree %>%
        keep.tip(., tip=m$spNames) 

#Varpart table
varpart_table <- varpart$vals %>%
   as.data.frame() %>%
   rownames_to_column(var="variable") %>%
   pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
   mutate(variable=factor(variable, levels=rev(levels.4a))) %>%
   mutate(genome=factor(genome, levels=rev(varpart_tree$tip.label)))

#Phylums
phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% varpart_tree$tip.label) %>%
    arrange(match(genome, varpart_tree$tip.label)) %>%
    mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
    column_to_rownames(var = "genome") %>%
    select(phylum)


colors_alphabetic <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% varpart_tree$tip.label) %>%
    arrange(match(genome, varpart_tree$tip.label)) %>%
     select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    select(colors) %>%
    pull()

# Basal ggtree
varpart_tree <- varpart_tree %>%
        force.ultrametric(.,method="extend") %>%
        ggtree(., size = 0.3)

# Add phylum colors next to the tree tips
varpart_tree <- gheatmap(varpart_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) +
   scale_fill_manual(values=colors_alphabetic)+
      labs(fill="Phylum")

#Reset fill scale to use a different colour profile in the heatmap
varpart_tree <- varpart_tree + new_scale_fill()

# Add variance stacked barplot
vertical_tree <-  varpart_tree +
        #scale_fill_manual(values=c("#34738f","#cccccc","#ed8a45","#b2b530","#be3e2b","#f6de6c","#83bb90"))+
        scale_fill_manual(values=c("#34738f","#cccccc","#ed8a45","#b2b530","#be3e2b","#83bb90","#f6de6c"))+ #"#122f3d"
        geom_fruit(
             data=varpart_table,
             geom=geom_bar,
             mapping = aes(x=value, y=genome, fill=variable, group=variable),
             pwidth = 2,
             offset = 0.05,
             width= 1,
             orientation="y",
             stat="identity")+
      labs(fill="Variable")

vertical_tree
```

```{r hmsc_postestimates, warning=FALSE, comments="", message=FALSE}
# Select desired support threshold
support=0.9
negsupport=1-support

# Basal tree
postestimates_tree <- genome_tree %>%
        keep.tip(., tip=m$spNames) 

#plotBeta(hM=m, post=getPostEstimate(hM=m, parName="Beta"), param = "Support", plotTree = TRUE, covNamesNumbers=c(1,0))

# Posterior estimate table
post_beta <- getPostEstimate(hM=m, parName="Beta")$support %>%
    as.data.frame() %>%
    mutate(variable=m$covNames) %>%
    pivot_longer(!variable, names_to = "genome", values_to = "value") %>%
    mutate(genome=factor(genome, levels=rev(postestimates_tree$tip.label))) %>%
    mutate(value = case_when(
          value >= support ~ "Positive",
          value <= negsupport ~ "Negative",
          TRUE ~ "Neutral")) %>%
    mutate(value=factor(value, levels=c("Positive","Neutral","Negative"))) %>%
    pivot_wider(names_from = variable, values_from = value) %>%
    # rename(intercept=2,
    #          species.grey=3,
    #          index500=4,
    #          season.autumn=5,
    #          season.winter=6,
    #          logseqdepth=7,
    #          species.grey_season.autumn=8,
    #          species.grey_season.winter=9) %>%
   # select(genome,builtup,species,season_autumn,season_winter, builtup_species,species_season_autumn,species_season_winter) %>%
    #rename(intercept=2, sp_vulgaris=3, area_semi=4, area_urban=5, season_spring=6, season_winter=7, logseqdepth=8, sp_vulgarisxarea_semi=9, sp_vulgarisxarea_urban =10, sp_vulgarisxseason_spring=11, sp_vulgarisxseason_winter=12) %>%
    #select(genome,sp_vulgaris,area_semi,area_urban,sp_vulgarisxarea_semi,sp_vulgarisxarea_urban,season_spring,season_winter,sp_vulgarisxseason_spring,sp_vulgarisxseason_winter) %>%
    column_to_rownames(var="genome")

#Phylums
phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% postestimates_tree$tip.label) %>%
    arrange(match(genome, varpart_tree$tip.label)) %>%
    mutate(phylum = factor(phylum, levels = unique(phylum))) %>%
    column_to_rownames(var = "genome") %>%
    select(phylum)


colors_alphabetic <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv") %>%
  right_join(genome_metadata, by=join_by(phylum == phylum)) %>%
    filter(genome %in% postestimates_tree$tip.label) %>%
    arrange(match(genome, varpart_tree$tip.label)) %>%
     select(phylum, colors) %>%
    unique() %>%
    arrange(phylum) %>%
    select(colors) %>%
    pull()

# Basal ggtree
postestimates_tree <- postestimates_tree %>%
        force.ultrametric(.,method="extend") %>%
        ggtree(., size = 0.3)

#Add phylum colors next to the tree tips
postestimates_tree <- gheatmap(postestimates_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) +
      scale_fill_manual(values=colors_alphabetic)+
      labs(fill="Phylum")

#Reset fill scale to use a different colour profile in the heatmap
postestimates_tree <- postestimates_tree + new_scale_fill()

# Add posterior significant heatmap

postestimates_tree <- gheatmap(postestimates_tree, post_beta, offset=0, width=0.5, colnames=TRUE, colnames_position="top",colnames_angle=90, colnames_offset_y=1, hjust=0) +
        scale_fill_manual(values=c("#be3e2b","#f4f4f4","#b2b530"))+
        labs(fill="Trend")

postestimates_tree +
        vexpand(.25, 1) # expand top 
```


```{r hmsc_correlations, warning=FALSE, comments="", message=FALSE}
#Compute the residual correlation matrix
OmegaCor = computeAssociations(m)

# Refernece tree (for sorting genomes)
genome_tree_subset <- genome_tree %>%
        keep.tip(., tip=m$spNames) 


#Co-occurrence matrix at the animal level
supportLevel = 0.95
toPlot = ((OmegaCor[[1]]$support>supportLevel)
          + (OmegaCor[[1]]$support<(1-supportLevel))>0)*OmegaCor[[1]]$mean

matrix <- toPlot %>% 
      as.data.frame() %>%
      rownames_to_column(var="genome1") %>%
      pivot_longer(!genome1, names_to = "genome2", values_to = "cor") %>%
      mutate(genome1= factor(genome1, levels=genome_tree_subset$tip.label)) %>%
      mutate(genome2= factor(genome2, levels=genome_tree_subset$tip.label)) %>%
      ggplot(aes(x = genome1, y = genome2, fill = cor)) +
            geom_tile() + 
            scale_fill_gradient2(low = "#be3e2b",
                       mid = "#f4f4f4",
                       high = "#b2b530")+
            theme_void()

vtree <- genome_tree_subset %>%
  force.ultrametric(.,method="extend") %>%
  ggtree(.)
  
#create composite figure
grid.arrange(grobs = list(vtree,matrix,vtree),
             layout_matrix = rbind(c(4,1,1,1,1,1,1,1,1,1,1,1),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2),
                                   c(3,2,2,2,2,2,2,2,2,2,2,2)))
```

```{r hmsc_pred_species, warning=FALSE, comments="", message=FALSE}
# Overall species prediction
pred_species <- constructGradient(m, 
                      focalVariable = "species", 
                      non.focalVariables = 1, 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE) %>%
             as.data.frame() %>%
             mutate(species=c("Sciurus vulgaris","Sciurus carolinensis")) %>%
             pivot_longer(!species, names_to = "genome", values_to = "value") %>%
             mutate(genome = sub("(.*\\..*\\.)[^.]+.*", "\\1", genome)) %>% #remove iteration suffix
             mutate(genome =  sub("\\.$", "", genome))
```

```{r hmsc_pred_species_plot, warning=FALSE, comments="", message=FALSE}
pred_species %>%
      pivot_wider(names_from = species, values_from = value) %>%
      unnest(c(`Sciurus carolinensis`, `Sciurus vulgaris`)) %>%
      mutate(diff_grey.red = `Sciurus carolinensis` - `Sciurus vulgaris`) %>%
      select(genome, diff_grey.red) %>%
      left_join(genome_metadata, by=join_by(genome==genome)) %>%
      mutate(genome= factor(genome, levels=genome_tree_subset$tip.label)) %>%
      ggplot(., aes(y=genome, x=diff_grey.red, fill=phylum, color=phylum)) +
          scale_color_manual(values=colors_alphabetic)+
          geom_vline(xintercept = 0)+
          scale_fill_manual(values=paste0(colors_alphabetic,"80"))+
          geom_boxplot(outlier.shape = NA) +
          theme_classic() +
          theme(axis.text.y = element_blank())
```

```{r hmsc_pred_area, warning=FALSE, comments="", message=FALSE}
gradient = c(0:100)
gradientlength = length(gradient)

# Overall urbanisation prediction
pred_urban <- constructGradient(m, 
                      focalVariable = "index500", 
                      non.focalVariables = 1, 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE) %>%
            do.call(rbind,.) %>%
            as.data.frame() %>%
            mutate(index500=rep(gradient,1000)) %>%
            pivot_longer(-index500, names_to = "genome", values_to = "value") %>%
             mutate(genome = sub("(.*\\..*\\.)[^.]+.*", "\\1", genome)) %>% #remove iteration suffix
             mutate(genome =  sub("\\.$", "", genome)) #remove iteration suffix
```

```{r hmsc_pred_area_plot, warning=FALSE, comments="", message=FALSE}
pred_urban %>%
      mutate(genome=factor(genome, levels=genome_tree_subset$tip.label)) %>%
      group_by(index500,genome) %>%
      summarise(mean=mean(value)) %>%
      ggplot(., aes(y=genome, x=index500, fill=mean, color=mean)) +
          geom_tile() +
          scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white") +
          theme_classic()+ 
          theme(
            axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()
          )
```

```{r hmsc_pred_area_sp, warning=FALSE, comments="", message=FALSE}

# Urbanisation Sciurus vulgaris prediction
pred_urban_SciVu <- constructGradient(m, 
                      focalVariable = "index500", 
                      non.focalVariables = list(species=list(3,"Sciurus vulgaris")), 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE)

# Urbanisation Sciurus carolinensis prediction
pred_urban_SciCa <- constructGradient(m, 
                      focalVariable = "index500", 
                      non.focalVariables = list(species=list(3,"Sciurus carolinensis")), 
                      ngrid=gradientlength) %>%
             predict(m, Gradient = ., expected = TRUE)
```

```{r hmsc_pred_area_plot_sp, warning=FALSE, comments="", message=FALSE, eval=FALSE}
pred_urban_SciVu %>%
      mutate(genome=factor(genome, levels=genome_tree_subset$tip.label)) %>%
      group_by(index500,genome) %>%
      summarise(mean=mean(value)) %>%
      ggplot(., aes(y=genome, x=index500, fill=mean, color=mean)) +
          geom_tile() +
          scale_fill_gradient(low = "#f4f4f4", high = "steelblue", na.value="white") +
          theme_classic()+ 
          theme(
            axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()
          )
```

<!--chapter:end:07-hmsc_analysis.Rmd-->

