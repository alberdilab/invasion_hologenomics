[["index.html", "AlberdiLab | Romeo et al. 2024 Study title to be added Chapter 1 Introduction 1.1 Prepare the R environment", " AlberdiLab | Romeo et al. 2024 Study title to be added Claudia Romeo1, […], and Antton Alberdi2 Last update: 2024-06-14 Chapter 1 Introduction This webbook contains all the code used for the analysis of metagenomic data from invasive Sciurus carolinensis and native Sciurus vulgaris squirrels along urbanization gradients and across seasons. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/alberdilab/invasion_hologenomics.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(tidyverse) library(devtools) library(tinytable) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(mapproj) library(RColorBrewer) library(reshape2) library(ggResidpanel) # For statistics # library(spaa) library(vegan) library(Rtsne) #library(geiger) library(hilldiv2) library(distillR) library(broom.mixed) library(gtsummary) library(lmerTest) library(lme4) library(lmerTest) library(emmeans) library(effects) library(car) library(Hmsc) library(corrplot) University of Copenhagen, claudia.romeo@sund.ku.dk↩︎ University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["data-preparation.html", "Chapter 2 Data preparation", " Chapter 2 Data preparation 2.0.0.1 Read counts This is the document containing the number of sequencing reads from each sample have been mapped to each MAG. Note that this is the raw data that needs to be further processed before running any statistics on them. read_counts &lt;- read.csv(&quot;data/squirrels_counts.csv&quot;, sep=&quot;;&quot;) %&gt;% rename(genome = 1) Generate a vector of genome names to be employed for filtering and sorting data in downstream steps. genomes &lt;- read_counts$genome # create list of genome names 2.0.0.2 Genome coverage Proportion of each genome covered by sequencing reads. genome_coverage &lt;- read.csv(&quot;data/squirrels_coverage.csv&quot;, sep=&quot;;&quot;) %&gt;% rename(genome = 1) 2.0.0.3 Sample metadata sample_metadata &lt;- read.csv(&quot;data/squirrels_metadata.csv&quot;,sep=&quot;;&quot;,header=T) sample_metadata &lt;- sample_metadata %&gt;% filter(!is.na(sampleID)) 2.0.0.4 Genome metadata genome_metadata &lt;- read.csv(&quot;data/squirrels_mag_info.csv&quot;,sep=&quot;;&quot;) %&gt;% rename(length=mag_size) %&gt;% arrange(match(genome, read_counts$genome)) 2.0.0.5 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. min_coverage=0.3 read_counts_filt &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% mutate(across(-1, ~ . * read_counts[[cur_column()]])) 2.0.0.6 Generate genome count table After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information. readlength=150 #change if sequencing read length is different genome_counts &lt;- read_counts_filt %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength) )) %&gt;% select_if(~!all(. == 0)) #remove samples with no MAGs 2.0.0.7 Genome tree genome_tree &lt;- read.tree(&quot;data/squirrels.tree&quot;) 2.0.0.8 MAG functional annotations These are the raw annotation table generated by DRAM, which are used to generate GIFT data using either distillR or KEGG. genome_gifts &lt;- read.csv(&quot;data/squirrels_distillr.csv&quot;, sep=&quot;;&quot;) genome_kegg &lt;- read.csv(&quot;data/squirrels_merged_kegg.csv&quot;, sep=&quot;;&quot;) 2.0.0.9 Colour palette ehi_phylum_colors &lt;- read.table(&quot;data/ehi_phylum_colors.tsv&quot;,sep=&quot;\\t&quot;,header=T,comment.char = &quot;&quot;) # Arrange colors alphabetically colors_alphabetic &lt;- ehi_phylum_colors %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() 2.0.0.10 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(read_counts, read_counts_filt, genome_counts, genome_tree, genome_metadata, genome_gifts, genome_kegg, sample_metadata, ehi_phylum_colors, colors_alphabetic, file = &quot;data/squirrels_data.Rdata&quot;) "],["data-summary.html", "Chapter 3 Data Summary 3.1 Sample summary 3.2 Sequencing data summary 3.3 MAGs summary", " Chapter 3 Data Summary rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) 3.1 Sample summary Summary of sampled individuals and analysed faecal samples. #number of samples length(sample_metadata$sample) [1] 190 #number of samples by species sample_metadata %&gt;% group_by(species) %&gt;% summarise(n_samples = length(sample)) %&gt;% tt() tinytable_j0kdaoakorj5lnnx3i2n .table td.tinytable_css_q5vm9lkkeo6o7s042aiq, .table th.tinytable_css_q5vm9lkkeo6o7s042aiq { border-bottom: solid 0.1em #d3d8dc; } species n_samples Sciurus carolinensis 80 Sciurus vulgaris 110 #number of samples by species and sex sample_metadata %&gt;% group_by(species, sex) %&gt;% summarise(n_samples = length(sample)) %&gt;% tt() tinytable_qxeh7myf48th7vh1xws8 .table td.tinytable_css_njpep1dnd5ch5z9w4b1v, .table th.tinytable_css_njpep1dnd5ch5z9w4b1v { border-bottom: solid 0.1em #d3d8dc; } species sex n_samples Sciurus carolinensis F 44 Sciurus carolinensis M 36 Sciurus vulgaris F 63 Sciurus vulgaris M 47 #number of samples by species and development sample_metadata %&gt;% group_by(species, development) %&gt;% summarise(n_samples = length(sample)) %&gt;% tt() tinytable_ln2mi3505jpo06se5cxm .table td.tinytable_css_o9miqv7cdzdcahm6umr7, .table th.tinytable_css_o9miqv7cdzdcahm6umr7 { border-bottom: solid 0.1em #d3d8dc; } species development n_samples Sciurus carolinensis Adult 71 Sciurus carolinensis Juvenile 2 Sciurus carolinensis Nursing 3 Sciurus carolinensis Pregnant 4 Sciurus vulgaris Adult 90 Sciurus vulgaris Juvenile 1 Sciurus vulgaris Nursing 8 Sciurus vulgaris Pregnant 11 #number of samples by species and type of area sample_metadata %&gt;% group_by(species,area_type) %&gt;% summarise(n_samples = length(sample)) %&gt;% tt() tinytable_91gto6yoiibtauu8nqib .table td.tinytable_css_hx654tdze3ihfozjc36y, .table th.tinytable_css_hx654tdze3ihfozjc36y { border-bottom: solid 0.1em #d3d8dc; } species area_type n_samples Sciurus carolinensis rural 29 Sciurus carolinensis suburban 24 Sciurus carolinensis urban 27 Sciurus vulgaris rural 37 Sciurus vulgaris suburban 30 Sciurus vulgaris urban 43 #number of distinct squirrels n_distinct(sample_metadata$animal) [1] 108 #number of squirrels by species and type of area sample_metadata %&gt;% group_by(species,area_type) %&gt;% summarise(distinct_squirrels = n_distinct(animal)) %&gt;% tt() tinytable_3nvmeu3b0q1i4and2lfn .table td.tinytable_css_b7i2q8pgj0r0djwgcl9q, .table th.tinytable_css_b7i2q8pgj0r0djwgcl9q { border-bottom: solid 0.1em #d3d8dc; } species area_type distinct_squirrels Sciurus carolinensis rural 14 Sciurus carolinensis suburban 13 Sciurus carolinensis urban 18 Sciurus vulgaris rural 21 Sciurus vulgaris suburban 14 Sciurus vulgaris urban 28 #number of squirrels by species and season sample_metadata %&gt;% group_by(species,season) %&gt;% summarise(distinct_squirrels = n_distinct(animal)) %&gt;% tt() tinytable_0ukfarwihoeualqlzpdp .table td.tinytable_css_0v8pjx2qylm0nn3g5seo, .table th.tinytable_css_0v8pjx2qylm0nn3g5seo { border-bottom: solid 0.1em #d3d8dc; } species season distinct_squirrels Sciurus carolinensis autumn 33 Sciurus carolinensis spring-summer 22 Sciurus carolinensis winter 25 Sciurus vulgaris autumn 39 Sciurus vulgaris spring-summer 38 Sciurus vulgaris winter 33 #n of analysed faecal samples ncol(read_counts) [1] 191 Geographical location of sampled red squirrel (light blue) and grey squirrel (pink) populations in Italy. #Summarise for generating map options(dplyr.summarise.inform = FALSE) sample_metadata_summary &lt;- sample_metadata %&gt;% #Group by geography and count samples select(sample, latitude, longitude, country, species) %&gt;% group_by(latitude, longitude, species) %&gt;% summarize(count = n()) %&gt;% ungroup() italy &lt;- map_data(&quot;world&quot;, region=&quot;italy&quot;) %&gt;% summarise(long = mean(long), lat = mean(lat)) #plotting on map sample_metadata_summary %&gt;% ggplot(.) + #render map geom_map( data=map_data(&quot;world&quot;, region=&quot;italy&quot;), map = map_data(&quot;world&quot;, region=&quot;italy&quot;), aes(long, lat, map_id=region), color = &quot;white&quot;, fill = &quot;#cccccc&quot;, linewidth = 0.2 ) + #render points geom_point( aes(x=longitude,y=latitude, color=species), alpha=0.5, shape=16) + #add general plot layout theme_minimal() + theme(legend.position = &quot;none&quot;, axis.title.x=element_blank(), axis.title.y=element_blank() ) + coord_map(&quot;mercator&quot;) 3.2 Sequencing data summary Total amount of sequencing data generated from the analysed samples. #amount of discarded data (GB) sum(round(((sample_metadata$metagenomic_bases+sample_metadata$host_bases)/ (1-sample_metadata$bases_lost_fastp_percent))- (sample_metadata$metagenomic_bases+sample_metadata$host_bases)))/1000000000 [1] 63.90045 #amount of host data (GB) sum(sample_metadata$host_bases)/1000000000 [1] 166.0275 #amount of metagenomic data (GB) sum(sample_metadata$metagenomic_bases)/1000000000 [1] 786.1584 #amount of estimated prokaryotic data (singleM) sum(sample_metadata$metagenomic_bases * sample_metadata$singlem_fraction)/1000000000 [1] 557.7475 Origin of DNA sequences obtained from each sample. sequence_fractions &lt;- read_counts %&gt;% pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) %&gt;% group_by(sample) %&gt;% summarise(mags = sum(value)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %&gt;% mutate(mags_bases = mags*146) %&gt;% mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %&gt;% mutate(unmapped_bases = metagenomic_bases - mags_bases) %&gt;% mutate(unmapped_bases = ifelse(unmapped_bases &lt; 0, 0, unmapped_bases)) %&gt;% select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases) mags_bases_mean &lt;- sequence_fractions %&gt;% mutate(mags_bases = mags_bases / 1000000000) %&gt;% select(mags_bases) %&gt;% pull() %&gt;% mean() sequence_fractions %&gt;% pivot_longer(!sample, names_to = &quot;fraction&quot;, values_to = &quot;value&quot;) %&gt;% mutate(value = value / 1000000000) %&gt;% mutate(fraction = factor(fraction, levels = c(&quot;lowqual_bases&quot;,&quot;host_bases&quot;,&quot;unmapped_bases&quot;,&quot;mags_bases&quot;))) %&gt;% ggplot(., aes(x = sample, y = value, fill=fraction)) + geom_bar(position=&quot;stack&quot;, stat = &quot;identity&quot;) + scale_fill_manual(values=c(&quot;#CCCCCC&quot;,&quot;#178a94&quot;,&quot;#ee8080&quot;,&quot;#d03161&quot;)) + geom_hline(yintercept = mags_bases_mean, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + labs(x = &quot;Samples&quot;, y = &quot;Amount of data (GB)&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = &quot;bottom&quot;) Sequencing assessment: difference between mapping rate and estimated singleM proportion # Estimated vs mapped prokaryotic fraction sequence_fractions &lt;- read_counts %&gt;% pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) %&gt;% group_by(sample) %&gt;% summarise(mags = sum(value)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %&gt;% mutate(mags_bases = mags*146) %&gt;% mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %&gt;% mutate(unmapped_bases = metagenomic_bases - mags_bases) %&gt;% mutate(unmapped_bases = ifelse(unmapped_bases &lt; 0, 0, unmapped_bases)) %&gt;% select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases) singlem_table &lt;- sequence_fractions %&gt;% mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% mutate(singlem_proportion = round(singlem_fraction*100,2)) %&gt;% select(sample,mags_proportion,singlem_proportion) %&gt;% mutate(mags_proportion = ifelse(singlem_proportion == 0, 0, mags_proportion)) %&gt;% #convert zeros to NA mutate(singlem_proportion = ifelse(singlem_proportion == 0, NA, singlem_proportion)) %&gt;% #convert zeros to NA mutate(singlem_proportion = ifelse(singlem_proportion &lt; mags_proportion, NA, singlem_proportion)) %&gt;% #if singlem is smaller, then NA, to simplify plot mutate(singlem_proportion = ifelse(singlem_proportion &gt; 100, 100, singlem_proportion)) #simplify singlem_table %&gt;% pivot_longer(!sample, names_to = &quot;proportion&quot;, values_to = &quot;value&quot;) %&gt;% mutate(proportion = factor(proportion, levels = c(&quot;mags_proportion&quot;,&quot;singlem_proportion&quot;))) %&gt;% ggplot(., aes(x = value, y = sample, color=proportion)) + geom_line(aes(group = sample), color = &quot;#f8a538&quot;) + geom_point() + scale_color_manual(values=c(&quot;#52e1e8&quot;,&quot;#876b53&quot;)) + theme_classic() + labs(y = &quot;Samples&quot;, x = &quot;Prokaryotic fraction (%)&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = &quot;right&quot;) # Export difference b/w mags and singlem proportions to be used later in script 05-diversity_models singlem &lt;- sequence_fractions %&gt;% mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% mutate(singlem_proportion = round(singlem_fraction*100,2)) %&gt;% mutate(mags_singlem = mags_proportion/singlem_proportion) %&gt;% mutate(est_mapp = ifelse(mags_singlem &gt;= 1, 1, mags_singlem)) %&gt;% select(sample,mags_singlem,est_mapp) write.table(singlem, file = &quot;data/singlem.csv&quot;, row.names = FALSE, dec = &quot;.&quot;, sep = &quot;;&quot;, quote = FALSE) 3.3 MAGs summary #number of MAGs nrow(read_counts) [1] 1687 #number of MAGs without species-level annotation (i.e., &quot;new species&quot;) genome_metadata %&gt;% filter(species == &quot;s__&quot;) %&gt;% nrow() [1] 1455 #number of phylums genome_metadata %&gt;% select(phylum) %&gt;% unique() %&gt;% pull() %&gt;% length() [1] 13 "],["mags-overview.html", "Chapter 4 MAGs overview 4.1 MAGs phylogeny 4.2 Genome quality 4.3 Functional attributes of MAGs 4.4 Functional ordination of MAGs (distillr)", " Chapter 4 MAGs overview rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) 4.1 MAGs phylogeny # Which phylum the MAG belongs to phyla &lt;- ehi_phylum_colors %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() # What is the genome size of the MAG in MBs (megabases) lengths &lt;- genome_metadata %&gt;% select(c(genome,length)) %&gt;% mutate(length=round(length/1000000,2)) # What is the completeness of the MAG mag_completeness &lt;- genome_metadata %&gt;% select(c(genome,completeness)) %&gt;% as.data.frame() %&gt;% remove_rownames() %&gt;% column_to_rownames(var = &quot;genome&quot;) # Generate the phylum color heatmap phylum_heatmap &lt;- ehi_phylum_colors %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome,phylum) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Create baseline circular genome tree circular_tree &lt;- force.ultrametric(genome_tree,method=&quot;extend&quot;) %&gt;% ggtree(., layout = &#39;circular&#39;, size = 0.1, angle=45) + xlim(-1, NA) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add phylum colors ring circular_tree &lt;- gheatmap(circular_tree, phylum_heatmap, offset=0.05, width=0.3, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic, name=&quot;Phylum&quot;) + #geom_tiplab2(size=1, hjust=-0.1) + theme(legend.position = &quot;right&quot;, plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0)) # Flush color scale to enable a new color scheme in the next ring circular_tree &lt;- circular_tree + new_scale_fill() # Add completeness ring circular_tree &lt;- circular_tree + #new_scale_fill() + scale_fill_gradient(low = &quot;#d1f4ba&quot;, high = &quot;#f4baba&quot;, name=&quot;Genome\\ncontamination&quot;) + geom_fruit( data=genome_metadata, geom=geom_bar, mapping = aes(x=completeness, y=genome, fill=contamination), offset = 0.55, orientation=&quot;y&quot;, stat=&quot;identity&quot;) # Add genome-size ring circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_manual(values = &quot;#cccccc&quot;) + geom_fruit( data=lengths, geom=geom_bar, mapping = aes(x=length, y=genome), offset = 0.05, orientation=&quot;y&quot;, stat=&quot;identity&quot;) #Plot circular tree circular_tree 4.2 Genome quality genome_metadata$completeness %&gt;% mean() [1] 84.89347 genome_metadata$completeness %&gt;% sd() [1] 15.4699 genome_metadata$contamination %&gt;% mean() [1] 2.013071 genome_metadata$contamination %&gt;% sd() [1] 2.10322 #create input table from original genome table genome_details &lt;- genome_metadata %&gt;% select(c(genome,domain,phylum,completeness,contamination,length)) %&gt;% mutate(length=round(length/1000000,2)) %&gt;% #change length to MBs rename(comp=completeness,cont=contamination,size=length) %&gt;% #rename columns remove_rownames() %&gt;% arrange(match(genome, rev(genome_tree$tip.label))) #sort MAGs according to phylogenetic tree #generate genome quality biplot genome_stats_biplot &lt;- genome_details %&gt;% ggplot(aes(x=comp,y=cont,size=size,color=phylum)) + geom_point(alpha=0.7) + ylim(c(10,0)) + scale_color_manual(values=colors_alphabetic) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) #generate contamination boxplot genome_stats_cont &lt;- genome_details %&gt;% ggplot(aes(y=cont)) + ylim(c(10,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) #generate completeness boxplot genome_stats_comp &lt;-genome_details %&gt;% ggplot(aes(x=comp)) + xlim(c(50,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) #create composite figure grid.arrange(grobs = list(genome_stats_comp,genome_stats_biplot,genome_stats_cont), layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3))) 4.3 Functional attributes of MAGs #Generate a basal utrametric tree for the sake of visualisation gift_tree &lt;- force.ultrametric(genome_tree,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #Add phylum colors next to the tree tips gift_tree &lt;- gheatmap(gift_tree, phylum_heatmap, offset=0, width=0.1, colnames=FALSE, color=NA) + scale_fill_manual(values=colors_alphabetic) + labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap gift_tree &lt;- gift_tree + new_scale_fill() gift_table &lt;- genome_gifts %&gt;% column_to_rownames(var=&quot;genome&quot;) #Add functions heatmap gift_tree &lt;- gheatmap(gift_tree, gift_table, offset=0.5, width=3.5, colnames=FALSE, color=NA) + vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;)+ labs(fill=&quot;GIFT&quot;) #Reset fill scale to use a different colour profile in the heatmap gift_tree &lt;- gift_tree + new_scale_fill() # Add completeness barplots gift_tree &lt;- gift_tree + geom_fruit(data=genome_metadata, geom=geom_bar, #grid.params=list(axis=&quot;x&quot;, text.size=2, nbreak = 1), axis.params=list(vline=TRUE), mapping = aes(x=length, y=genome, fill=completeness), offset = 3.8, orientation=&quot;y&quot;, stat=&quot;identity&quot;) + scale_fill_gradient(low = &quot;#cf8888&quot;, high = &quot;#a2cc87&quot;) + labs(fill=&quot;Genome\\ncompleteness&quot;) #Plot combined tree + heatmap gift_tree + theme(legend.position=&#39;right&#39;) 4.4 Functional ordination of MAGs (distillr) distillr_table &lt;- genome_gifts %&gt;% column_to_rownames(var=&quot;genome&quot;) # Generate the tSNE ordination tSNE_func2 &lt;- Rtsne(X=distillr_table, dims = 2, check_duplicates = FALSE) # Plot the ordination tSNE_func2$Y %&gt;% as.data.frame() %&gt;% mutate(genome=rownames(distillr_table)) %&gt;% inner_join(genome_metadata, by=&quot;genome&quot;) %&gt;% rename(tSNE1=&quot;V1&quot;, tSNE2=&quot;V2&quot;) %&gt;% select(genome,phylum,tSNE1,tSNE2, completeness) %&gt;% ggplot(aes(x = tSNE1, y = tSNE2, color = phylum, size=completeness))+ geom_point(shape=16, alpha=0.7) + scale_color_manual(values=colors_alphabetic) + theme_minimal() + theme(legend.position = &quot;right&quot;) "],["community-composition.html", "Chapter 5 Community composition 5.1 Count data preparation 5.2 Genomes by host species 5.3 Taxonomic composition of samples", " Chapter 5 Community composition rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) 5.1 Count data preparation genome_counts_log &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% mutate_all(~log10(.+1)) #fixed: mutate_at(vars(), ~log10(.+1))) was not working genome_counts_pivot &lt;- genome_counts %&gt;% mutate_at(vars(-genome),~./sum(.)) %&gt;% #apply TSS normalisation pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;count&quot;) %&gt;% #reduce to minimum number of columns left_join(., genome_metadata, by = join_by(genome == genome)) %&gt;% #append taxonomy mutate(phylum = fct_relevel(phylum, rev(ehi_phylum_colors$phylum))) #sort phyla by taxonomy genome_counts_by_host &lt;- sample_metadata %&gt;% select(&quot;sample&quot;,&quot;species&quot;,&quot;area_type&quot;, &quot;development&quot;) %&gt;% rename(host_sp=species) %&gt;% left_join(genome_counts_pivot,., by=join_by(&quot;sample&quot; == &quot;sample&quot;)) #%&gt;% #mutate(sample=factor(sample, levels = sample_sort)) #alternative to join: sorting by area_type # Retrieve taxonomy colors to use standardised EHI colors phylum_colors &lt;- ehi_phylum_colors %&gt;% filter(phylum %in% unique(genome_counts_by_host$phylum)) %&gt;% select(colors) %&gt;% pull() %&gt;% rev() phylum_colors &lt;- c(phylum_colors,&quot;#cccccc&quot;) #REMOVE! ONLY FOR ARCHAEANS # Which host species each genome can be found in genomes_by_species &lt;- genome_counts_by_host %&gt;% filter(count&gt;0) %&gt;% group_by(genome) %&gt;% mutate(host = if_else(all(host_sp == &quot;Sciurus vulgaris&quot;), &quot;only red&quot;, if_else(all(host_sp == &quot;Sciurus carolinensis&quot;), &quot;only grey&quot;, &quot;both&quot;))) %&gt;% select(genome, host) %&gt;% distinct(genome, .keep_all = TRUE) %&gt;% left_join(.,genome_metadata, by=&#39;genome&#39;) genomes_by_species$host &lt;-factor(genomes_by_species$host, levels = c(&quot;both&quot;, &quot;only red&quot;, &quot;only grey&quot;)) 5.2 Genomes by host species # Which phylum the MAG belongs to phyla &lt;- ehi_phylum_colors %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() # Generate the phylum color heatmap phylum_heatmap &lt;- ehi_phylum_colors %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome,phylum) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Create baseline circular genome tree circular_tree &lt;- force.ultrametric(genome_tree,method=&quot;extend&quot;) %&gt;% ggtree(., layout = &#39;circular&#39;, size = 0.1, angle=45) + xlim(-1, NA) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add phylum colors ring circular_tree &lt;- gheatmap(circular_tree, phylum_heatmap, offset=0.0, width=0.2, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic, name=&quot;Phylum&quot;) + #geom_tiplab2(size=1, hjust=-0.1) + theme(legend.position = &quot;right&quot;, plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0)) #Flush color scale to enable a new color scheme in the next ring circular_tree &lt;- circular_tree + new_scale_fill() # Add host ring circular_tree_h &lt;- circular_tree + new_scale_fill() + scale_fill_manual(values = c(&quot;black&quot;, &quot;#ed2939&quot;, &quot;#92a0ad&quot;), name=&quot;Host\\nspecies&quot;) + #&quot;#cc3333&quot;, &quot;#999999&quot; geom_fruit( data=genomes_by_species, geom=geom_tile, mapping = aes(y=genome, fill=host), offset = 0.35, width=0.2) #Plot circular tree circular_tree_h #number of MAGs by host species genomes_by_species %&gt;% dplyr::group_by(host) %&gt;% summarise(n=length(host), percentage=(length(host)/1687)*100) %&gt;% tt() tinytable_faoiiyu9vugi182hfh8j .table td.tinytable_css_m16u28uy5otx7xhudbzu, .table th.tinytable_css_m16u28uy5otx7xhudbzu { border-bottom: solid 0.1em #d3d8dc; } host n percentage both 505 29.93480 only red 482 28.57143 only grey 700 41.49378 #most abundant phyla by host species genome_counts_by_host %&gt;% #filter(count&gt;0) %&gt;% group_by(host_sp,phylum) %&gt;% summarise(rel_abundance=sum(count)) %&gt;% top_n(3, rel_abundance) %&gt;% arrange(by_group=host_sp, desc(rel_abundance)) %&gt;% tt() tinytable_lm7dowu4egrbc7qcp6wy .table td.tinytable_css_n0hvkt45pb1edd4i1phh, .table th.tinytable_css_n0hvkt45pb1edd4i1phh { border-bottom: solid 0.1em #d3d8dc; } host_sp phylum rel_abundance Sciurus carolinensis p__Bacillota_A 55.472233 Sciurus carolinensis p__Bacteroidota 16.149398 Sciurus carolinensis p__Bacillota 2.498674 Sciurus vulgaris p__Bacillota_A 48.125675 Sciurus vulgaris p__Bacteroidota 32.438965 Sciurus vulgaris p__Actinomycetota 16.517267 #most common phyla by host species genome_counts_by_host %&gt;% #filter(count&gt;0) %&gt;% group_by(host_sp,phylum) %&gt;% summarise(freq=sum(count&gt;0)/length(host_sp)) %&gt;% top_n(3, freq) %&gt;% arrange(by_group=host_sp, desc(freq)) %&gt;% tt() tinytable_3uiy23vd60osb5ob1vcm .table td.tinytable_css_ayhqcjfjq0hkhzborllk, .table th.tinytable_css_ayhqcjfjq0hkhzborllk { border-bottom: solid 0.1em #d3d8dc; } host_sp phylum freq Sciurus carolinensis p__Campylobacterota 0.46250000 Sciurus carolinensis p__Verrucomicrobiota 0.30000000 Sciurus carolinensis p__Bacillota_B 0.27291667 Sciurus vulgaris p__Campylobacterota 0.14545455 Sciurus vulgaris p__Bacillota_C 0.13522727 Sciurus vulgaris p__Bacillota_B 0.08333333 #most abundant class by host species genome_counts_by_host %&gt;% filter(count&gt;0) %&gt;% group_by(host_sp,class) %&gt;% summarise(total_count=sum(count)) %&gt;% top_n(5, total_count) %&gt;% arrange(by_group=host_sp, desc(total_count)) %&gt;% tt() tinytable_ak1eje38g6riavkqosp1 .table td.tinytable_css_jtrc54ueobrhcfrfjxhn, .table th.tinytable_css_jtrc54ueobrhcfrfjxhn { border-bottom: solid 0.1em #d3d8dc; } host_sp class total_count Sciurus carolinensis c__Clostridia 55.472233 Sciurus carolinensis c__Bacteroidia 16.149398 Sciurus carolinensis c__Bacilli 2.498674 Sciurus carolinensis c__Verrucomicrobiae 2.094198 Sciurus carolinensis c__Vampirovibrionia 1.253040 Sciurus vulgaris c__Clostridia 48.125675 Sciurus vulgaris c__Bacteroidia 32.438965 Sciurus vulgaris c__Actinomycetia 16.040176 Sciurus vulgaris c__Bacilli 8.233587 Sciurus vulgaris c__Gammaproteobacteria 2.254878 #most abundant family by host species genome_counts_by_host %&gt;% filter(count&gt;0) %&gt;% group_by(host_sp,family) %&gt;% summarise(abundance=sum(count)) %&gt;% top_n(5, abundance) %&gt;% arrange(by_group=host_sp, desc(abundance)) %&gt;% tt() tinytable_tdxthrz1vz037bd34pxc .table td.tinytable_css_jq411l3tyhheynu2nsny, .table th.tinytable_css_jq411l3tyhheynu2nsny { border-bottom: solid 0.1em #d3d8dc; } host_sp family abundance Sciurus carolinensis f__Lachnospiraceae 29.253695 Sciurus carolinensis f__Oscillospiraceae 16.103469 Sciurus carolinensis f__Bacteroidaceae 9.370700 Sciurus carolinensis f__Muribaculaceae 4.737998 Sciurus carolinensis f__Borkfalkiaceae 2.527615 Sciurus vulgaris f__Lachnospiraceae 35.793100 Sciurus vulgaris f__Bacteroidaceae 21.149209 Sciurus vulgaris f__Bifidobacteriaceae 15.986288 Sciurus vulgaris f__Muribaculaceae 9.598616 Sciurus vulgaris f__Oscillospiraceae 4.267142 vertical_tree &lt;- force.ultrametric(genome_tree,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** Trovata più di una classe &quot;phylo&quot; in cache; si utilizza il primo, dal namespace &#39;phyloseq&#39; Definito anche da &#39;tidytree&#39; #Add phylum colors vertical_tree &lt;- gheatmap(vertical_tree, phylum_heatmap, offset=0, width=0.1, colnames=FALSE, color=NA) + scale_fill_manual(values=colors_alphabetic) Scale for y is already present. Adding another scale for y, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. #Reset fill scale vertical_tree &lt;- vertical_tree + new_scale_fill() #Add counts vertical_tree &lt;- gheatmap(vertical_tree, genome_counts_log, offset=0.5, width=3.5, color=NA, colnames=FALSE) + #, colnames_angle=90, font.size=2, colnames_position=&quot;top&quot;, colnames_offset_y = 9 vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) Scale for y is already present. Adding another scale for y, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. #Plot tree vertical_tree + theme(legend.position=&#39;right&#39;) 5.3 Taxonomic composition of samples # sample_sort &lt;- sample_metadata %&gt;% # arrange(Area_type) %&gt;% # select(sample) %&gt;% # pull() # Plot stacked barplot ggplot(genome_counts_by_host, aes(x=sample,y=count,fill=phylum, group=phylum))+ #grouping enables keeping the same sorting of taxonomic units geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.02)+ #plot stacked bars with white borders scale_fill_manual(values=phylum_colors, name=&quot;Phylum&quot;) + labs(y = &quot;Relative abundance&quot;) + guides(fill = guide_legend(ncol = 1)) + facet_nested(~host_sp, scales=&quot;free&quot;, space=&quot;free&quot;) + theme(axis.text.x = element_blank(), axis.title.x = element_blank(), panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(linewidth = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), legend.position=&quot;right&quot;, ) phylum_summary &lt;- genome_counts_by_host %&gt;% group_by(sample,host_sp,phylum) %&gt;% summarise(relabun=sum(count)) phylum_summary %&gt;% group_by(phylum) %&gt;% summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) # A tibble: 13 × 3 phylum mean sd &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 p__Elusimicrobiota 0.00170 0.00694 2 p__Cyanobacteriota 0.00895 0.0118 3 p__Bacillota 0.0565 0.110 4 p__Bacillota_B 0.00255 0.00418 5 p__Bacillota_C 0.00429 0.00664 6 p__Bacillota_A 0.545 0.252 7 p__Actinomycetota 0.0898 0.234 8 p__Patescibacteria 0.0000251 0.000346 9 p__Pseudomonadota 0.0180 0.0738 10 p__Campylobacterota 0.00521 0.0250 11 p__Bacteroidota 0.256 0.178 12 p__Verrucomicrobiota 0.0116 0.0229 13 p__Thermoplasmatota 0.000351 0.00366 phylum_arrange &lt;- phylum_summary %&gt;% group_by(phylum) %&gt;% summarise(mean=mean(relabun)) %&gt;% arrange(-mean) %&gt;% select(phylum) %&gt;% pull() phylum_summary %&gt;% filter(phylum %in% phylum_arrange) %&gt;% mutate(phylum=factor(phylum,levels=rev(phylum_arrange))) %&gt;% ggplot(aes(x=relabun, y=phylum, group=phylum, color=phylum)) + scale_color_manual(values=phylum_colors[rev(phylum_arrange)], name=&quot;Phylum&quot;) + geom_jitter(alpha=0.5) + facet_nested(~host_sp, scales=&quot;free&quot;, space=&quot;free&quot;) + theme_minimal() + theme(legend.position=&quot;right&quot;) + labs(y=&quot;Phylum&quot;,x=&quot;Relative abundance&quot;) family_summary &lt;- genome_counts_by_host %&gt;% group_by(sample,host_sp,family) %&gt;% summarise(relabun=sum(count)) family_summary %&gt;% group_by(family) %&gt;% summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) %&gt;% arrange(-mean) # A tibble: 74 × 3 family mean sd &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 f__Lachnospiraceae 0.342 0.192 2 f__Bacteroidaceae 0.161 0.146 3 f__Oscillospiraceae 0.107 0.104 4 f__Bifidobacteriaceae 0.0841 0.233 5 f__Muribaculaceae 0.0755 0.0956 6 f__Ruminococcaceae 0.0329 0.0377 7 f__Borkfalkiaceae 0.0192 0.0270 8 f__Lactobacillaceae 0.0163 0.0514 9 f__Streptococcaceae 0.0161 0.0866 10 f__Acutalibacteraceae 0.0109 0.0135 # ℹ 64 more rows family_arrange &lt;- family_summary %&gt;% group_by(family) %&gt;% summarise(mean=sum(relabun)) %&gt;% arrange(-mean) %&gt;% select(family) %&gt;% pull() family_summary %&gt;% left_join(genome_metadata %&gt;% select(family,phylum) %&gt;% unique(),by=join_by(family==family)) %&gt;% left_join(sample_metadata,by=join_by(sample==sample)) %&gt;% filter(family %in% family_arrange[1:20]) %&gt;% mutate(family=factor(family,levels=rev(family_arrange[1:20]))) %&gt;% filter(relabun &gt; 0) %&gt;% ggplot(aes(x=relabun, y=family, group=family, color=phylum)) + scale_color_manual(values=colors_alphabetic) + geom_jitter(alpha=0.5) + facet_grid(.~host_sp)+ theme_minimal() + labs(y=&quot;Family&quot;, x=&quot;Relative abundance&quot;, color=&quot;Phylum&quot;) genus_summary &lt;- genome_counts_by_host %&gt;% group_by(sample,host_sp,genus) %&gt;% summarise(relabun=sum(count)) genus_summary %&gt;% group_by(genus) %&gt;% summarise(mean=mean(relabun, na.rm=TRUE),sd=sd(relabun, na.rm=TRUE)) %&gt;% arrange(-mean) # A tibble: 348 × 3 genus mean sd &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 g__Bifidobacterium 0.0841 0.233 2 g__Prevotella 0.0732 0.0968 3 g__Acetatifactor 0.0429 0.0621 4 g__ 0.0383 0.0427 5 g__Eisenbergiella 0.0322 0.0556 6 g__Faecousia 0.0270 0.0366 7 g__CAG-95 0.0219 0.0326 8 g__Roseburia 0.0215 0.0526 9 g__Phocaeicola 0.0194 0.0292 10 g__Dysosmobacter 0.0179 0.0175 # ℹ 338 more rows genus_arrange &lt;- genus_summary %&gt;% group_by(genus) %&gt;% summarise(mean=sum(relabun)) %&gt;% arrange(-mean) %&gt;% select(genus) %&gt;% pull() genus_summary %&gt;% left_join(genome_metadata %&gt;% select(genus,phylum) %&gt;% unique(),by=join_by(genus==genus)) %&gt;% left_join(sample_metadata,by=join_by(sample==sample)) %&gt;% filter(genus %in% genus_arrange[1:20]) %&gt;% mutate(genus=factor(genus,levels=rev(genus_arrange[1:20]))) %&gt;% filter(relabun &gt; 0) %&gt;% ggplot(aes(x=relabun, y=genus, group=genus, color=phylum)) + scale_color_manual(values=colors_alphabetic) + geom_jitter(alpha=0.5) + facet_grid(.~host_sp)+ theme_minimal() + labs(y=&quot;Genus&quot;, x=&quot;Relative abundance&quot;, color=&quot;Phylum&quot;) Warning in left_join(., genome_metadata %&gt;% select(genus, phylum) %&gt;% unique(), : Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1 of `x` matches multiple rows in `y`. ℹ Row 41 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. "],["diversity-analyses.html", "Chapter 6 Diversity analyses 6.1 Data preparation 6.2 Alpha Diversity metrics 6.3 Alpha Diversity comparisons 6.4 Alpha diversity models 6.5 Neutral beta diversity", " Chapter 6 Diversity analyses rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) singlem &lt;- read.csv(&quot;data/singlem.csv&quot;,sep=&quot;;&quot;,header=T) options(contrasts = c(&#39;contr.sum&#39;,&#39;contr.poly&#39;)) 6.1 Data preparation #Change genome names column to row names genome_counts &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) genome_gifts &lt;- genome_gifts %&gt;% column_to_rownames(var=&quot;genome&quot;) #Get list of present MAGs present_MAGs &lt;- genome_counts %&gt;% filter(rowSums(.[, -1]) != 0) %&gt;% rownames() #Remove samples with all zeros (no data after filtering) genome_counts_filt &lt;- genome_counts %&gt;% select_if(~!all(. == 0)) #Align distillr annotations with present MAGs and remove all-zero and all-one traits present_MAGs &lt;- present_MAGs[present_MAGs %in% rownames(genome_gifts)] genome_gifts_filt &lt;- genome_gifts[present_MAGs,] %&gt;% select_if(~!all(. == 0)) %&gt;% #remove all-zero modules select_if(~!all(. == 1)) #remove all-one modules #Align tree with present MAGs tree_filt &lt;- keep.tip(genome_tree,present_MAGs) #Filter count table to only contain present MAGs after gifts filtering genome_counts_filt &lt;- genome_counts[present_MAGs,] #Calculate sequence fractions for each samples sequence_fractions &lt;- read_counts %&gt;% pivot_longer(-genome, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) %&gt;% group_by(sample) %&gt;% dplyr::summarize(mags = sum(value)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %&gt;% mutate(mags_bases = mags*146) %&gt;% mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %&gt;% mutate(unmapped_bases = metagenomic_bases - mags_bases) %&gt;% mutate(unmapped_bases = ifelse(unmapped_bases &lt; 0, 0, unmapped_bases)) %&gt;% select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases) 6.2 Alpha Diversity metrics #ALPHA DIVERSITY q0n &lt;- hilldiv2::hilldiv(genome_counts,q=0) %&gt;% c() Neutral Hill numbers of q0 q1n &lt;- hilldiv2::hilldiv(genome_counts,q=1) %&gt;% c() Neutral Hill numbers of q1 q1p &lt;- hilldiv2::hilldiv(genome_counts,q=1,tree=genome_tree) %&gt;% c() Phylogenetic Hill numbers of q1 dist &lt;- hilldiv2::traits2dist(genome_gifts_filt, method=&quot;gower&quot;) q1f &lt;- hilldiv2::hilldiv(genome_counts_filt,q=1,dist=dist) %&gt;% c() Functional Hill numbers of q1 # Merge all metrics alpha_div &lt;- cbind(sample=colnames(genome_counts),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3),func=round(q1f,3)) %&gt;% as.data.frame() columns &lt;- c(&quot;richness&quot;,&quot;neutral&quot;,&quot;phylo&quot;,&quot;func&quot;, &quot;mapped&quot;,&quot;total&quot;) # Add amount of sequencing data to the table alpha_div &lt;- alpha_div %&gt;% left_join(sequence_fractions, by = join_by(sample == sample)) %&gt;% #add sequencing depth information mutate(mapped=round(mags_bases/1000000000,3)) %&gt;% #modify depth to million reads mutate(total=round((mags_bases+unmapped_bases+host_bases+lowqual_bases)/1000000000,3)) %&gt;% select(sample,richness,neutral,phylo,func,mapped,total) %&gt;% mutate(across(-1, as.numeric)) squirrel_colors &lt;- c(&quot;#999999&quot;, &quot;#cc3333&quot;) alpha_div %&gt;% left_join(sample_metadata, by=&#39;sample&#39;) %&gt;% select(sample, species, richness, neutral,phylo,func, mapped, total) %&gt;% mutate(species = factor(species), # Convert to factor if necessary sample = factor(sample, levels = unique(sample)[order(species)])) %&gt;% pivot_longer(-c(sample, species), names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% ggplot(aes(x=value, y=sample, fill=species)) + geom_bar(stat=&#39;identity&#39;) + scale_fill_manual(values=squirrel_colors) + facet_wrap(~ data, scales=&quot;free_x&quot;, ncol=6) + #facet_grid(species ~ data, scales=&quot;free_x&quot;, space=&quot;fixed&quot;) + #force_panelsizes(ro#ws = 2, cols = 3, TRUE) + theme_classic() + theme( strip.background = element_blank(), panel.grid.minor.x = element_line(size=.1, color=&quot;grey&quot;), panel.spacing = unit(0, &quot;lines&quot;), axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), legend.position = &quot;none&quot; ) # #table # kable(alpha_div) 6.3 Alpha Diversity comparisons 6.3.1 By species and sex squirrel_colors &lt;- c(&quot;#999999&quot;, &quot;#cc3333&quot;) sex_colors &lt;- c(&quot;turquoise3&quot;, &quot;indianred2&quot;) neutral.sex &lt;- alpha_div %&gt;% select(sample,neutral) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;sex&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=sex_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Neutral Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) phylo.sex &lt;- alpha_div %&gt;% select(sample,phylo) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;sex&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=sex_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Phylogenetic Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) func.sex &lt;- alpha_div %&gt;% select(sample,func) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;sex&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=sex_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Functional Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) sex.legend &lt;- get_legend(neutral.sex) ggarrange(neutral.sex, phylo.sex, func.sex, #+ rremove(&quot;x.text&quot;), legend.grob = sex.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) 6.3.2 By species and urbanisation sample_metadata$area_type &lt;-factor(sample_metadata$area_type, levels = c(&quot;rural&quot;, &quot;suburban&quot;, &quot;urban&quot;)) area_colors &lt;- c(&quot;#76b183&quot;,&quot;#d57d2c&quot;,&quot;#6b7398&quot;) #neutral alpha by species*area_type neutral.urb &lt;- alpha_div %&gt;% select(sample,neutral) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Neutral Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Urbanisation&quot;), fill=&quot;none&quot;) #phylogenetic alpha by species*area_type phylo.urb &lt;- alpha_div %&gt;% select(sample,phylo) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Phylogenetic Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) #functional (distillr-based) alpha by species*area_type func.urb &lt;- alpha_div %&gt;% select(sample,func) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Functional Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) urb.legend &lt;- get_legend(neutral.urb) ggarrange(neutral.urb, phylo.urb, func.urb, #+ rremove(&quot;x.text&quot;), legend.grob = urb.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) 6.3.3 By species and season sample_metadata$season &lt;-factor(sample_metadata$season, levels = c(&quot;spring-summer&quot;, &quot;autumn&quot;, &quot;winter&quot;)) season_colors &lt;- c(&quot;#76b183&quot;,&quot;#e5bd5b&quot;,&quot;#6b7398&quot;) #neutral alpha by species*season neutral.seas &lt;- alpha_div %&gt;% select(sample,neutral) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;season&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=season_colors) + scale_fill_manual(values=paste0(season_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Neutral Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Season&quot;), fill=&quot;none&quot;) #phylogenetic alpha by species*season phylo.seas &lt;- alpha_div %&gt;% select(sample,phylo) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;season&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=season_colors) + scale_fill_manual(values=paste0(season_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Phylogenetic Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) #functional (distillr-based) alpha by species*season func.seas &lt;- alpha_div %&gt;% select(sample,func) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;season&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=season_colors) + scale_fill_manual(values=paste0(season_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Functional Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) seas.legend &lt;- get_legend(neutral.seas) ggarrange(neutral.seas, phylo.seas, func.seas, #+ rremove(&quot;x.text&quot;), legend.grob = seas.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) 6.3.4 By species and development #neutral alpha by species*season neutral.dev &lt;- alpha_div %&gt;% select(sample,neutral) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;development&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + stat_compare_means() + theme_classic() + labs(y = &quot;Neutral Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Development&quot;), fill=&quot;none&quot;) #phylogenetic alpha by species*season phylo.dev &lt;- alpha_div %&gt;% select(sample,phylo) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;development&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + stat_compare_means() + theme_classic() + labs(y = &quot;Phylogenetic Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) #functional (distillr-based) alpha by species*season func.dev &lt;- alpha_div %&gt;% select(sample,func) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;value&quot;, color = &quot;development&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + stat_compare_means() + theme_classic() + labs(y = &quot;Functional Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) dev.legend &lt;- get_legend(neutral.seas) ggarrange(neutral.dev, phylo.dev, func.dev, #+ rremove(&quot;x.text&quot;), legend.grob = seas.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) 6.3.5 Alpha diversity and sequencing effort #sequencing effort and diversity ggplot(alpha_div, aes(x=mapped,y=neutral,label=sample)) + geom_smooth(method=&#39;lm&#39;, formula= y~x, color=&#39;#e08dde&#39;, fill=&#39;#e08dde&#39;) + geom_point(alpha=0.5, color=&quot;#6c9ebc&quot;) + geom_label_repel(max.overlaps = 100, cex=0.7) + labs(x = &quot;GBs mapped to MAGs&quot;, y = &quot;Neutral diversity (effective number of MAGs)&quot;) + theme_classic() + theme(legend.position=&quot;none&quot;) 6.4 Alpha diversity models 6.4.1 Data preparation for GLMMs diversity.data &lt;- alpha_div %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% mutate(season=factor(season, levels = c(&quot;spring-summer&quot;, &quot;autumn&quot;, &quot;winter&quot;))) %&gt;% right_join(singlem, by = join_by(sample == sample)) %&gt;% group_by(species) %&gt;% mutate(index500_st = scale(index500, center=T, scale=T)[,1]) %&gt;% ungroup() %&gt;% filter(sample!=&quot;EHI02263&quot;) %&gt;% #remove outlier filter(development==&quot;Adult&quot;) #remove juveniles, nursing and pregnant females #check whether a low domain-adjusted mapping rate (DAMR) is associated with low diversity estimates ggplot(diversity.data, aes(x=est_mapp, y=neutral)) + geom_point(size=3, alpha=0.5, color=&quot;#6c9ebc&quot;) + labs(x = &quot;DAMR (mapping rate to MAG catalogue/singleM microbial fraction estimate)&quot;, y = &quot;Neutral diversity (effective number of MAGs)&quot;) + theme_classic() + theme(legend.position=&quot;none&quot;) diversity.data &lt;- diversity.data %&gt;% filter(mags_singlem &gt; 0.8) #remove 5 samples with low DAMR #str(diversity.data) # check y distributions plot(diversity.data$neutral) hist(diversity.data$neutral, breaks=30) d &lt;- density(diversity.data$neutral) plot(d) plot(diversity.data$phylo) hist(diversity.data$phylo, breaks=30) d &lt;- density(diversity.data$phylo) plot(d) plot(diversity.data$func) hist(diversity.data$func, breaks=30) d &lt;- density(diversity.data$func) plot(d) 6.4.2 Bayesian models - neutral alpha set.seed(123) neutral.brm &lt;-brm(neutral ~ species + index500 + season + + species:index500 + species:season + (1|animal) + (1|sampling_site), data=diversity.data, family=gaussian(), chains = 3, iter = 3000, warmup = 1000) SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 1). Chain 1: Chain 1: Gradient evaluation took 0.000127 seconds Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.27 seconds. Chain 1: Adjust your expectations accordingly! Chain 1: Chain 1: Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 1: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 1: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 1: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 1: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 1: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 1: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 1: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 1: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 1: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) Chain 1: Chain 1: Elapsed Time: 0.831 seconds (Warm-up) Chain 1: 1.774 seconds (Sampling) Chain 1: 2.605 seconds (Total) Chain 1: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 2). Chain 2: Chain 2: Gradient evaluation took 3.3e-05 seconds Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.33 seconds. Chain 2: Adjust your expectations accordingly! Chain 2: Chain 2: Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 2: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 2: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 2: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 2: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 2: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 2: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 2: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 2: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 2: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) Chain 2: Chain 2: Elapsed Time: 0.91 seconds (Warm-up) Chain 2: 1.75 seconds (Sampling) Chain 2: 2.66 seconds (Total) Chain 2: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 3). Chain 3: Chain 3: Gradient evaluation took 3.2e-05 seconds Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.32 seconds. Chain 3: Adjust your expectations accordingly! Chain 3: Chain 3: Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 3: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 3: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 3: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 3: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 3: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 3: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 3: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 3: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 3: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) Chain 3: Chain 3: Elapsed Time: 0.991 seconds (Warm-up) Chain 3: 1.958 seconds (Sampling) Chain 3: 2.949 seconds (Total) Chain 3: #assessing model fit plot(neutral.brm) pairs(neutral.brm) #posterior predictive check pp_check(neutral.brm) summary(neutral.brm) Family: gaussian Links: mu = identity; sigma = identity Formula: neutral ~ species + index500 + season + +species:index500 + species:season + (1 | animal) + (1 | sampling_site) Data: diversity.data (Number of observations: 155) Draws: 3 chains, each with iter = 3000; warmup = 1000; thin = 1; total post-warmup draws = 6000 Multilevel Hyperparameters: ~animal (Number of levels: 97) Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sd(Intercept) 4.66 3.29 0.18 12.14 1.00 1873 2926 ~sampling_site (Number of levels: 21) Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sd(Intercept) 8.61 3.87 1.37 16.85 1.00 1569 2068 Regression Coefficients: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS Intercept 88.48 5.99 76.96 100.68 1.00 7204 4697 species1 41.98 5.95 29.94 53.22 1.00 5467 3870 index500 -31.93 13.11 -58.68 -6.23 1.00 7077 4534 season1 4.35 3.10 -1.78 10.46 1.00 9435 4580 season2 -5.83 2.81 -11.23 -0.12 1.00 7406 4616 species1:index500 -9.12 13.15 -34.47 16.99 1.00 5640 3956 species1:season1 -3.92 3.12 -9.98 2.12 1.00 10205 5103 species1:season2 -1.23 2.82 -6.65 4.31 1.00 10816 5066 Further Distributional Parameters: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sigma 24.48 1.63 21.42 27.91 1.00 5590 4324 Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS and Tail_ESS are effective sample size measures, and Rhat is the potential scale reduction factor on split chains (at convergence, Rhat = 1). describe_posterior(neutral.brm) Summary of Posterior Distribution Parameter | Median | 95% CI | pd | ROPE | % in ROPE | Rhat | ESS ----------------------------------------------------------------------------------------------------- (Intercept) | 88.32 | [ 76.96, 100.68] | 100% | [-4.85, 4.85] | 0% | 1.000 | 7082.00 species1 | 42.09 | [ 29.94, 53.22] | 100% | [-4.85, 4.85] | 0% | 1.000 | 5369.00 index500 | -31.89 | [-58.68, -6.23] | 99.07% | [-4.85, 4.85] | 0% | 1.000 | 7042.00 season1 | 4.36 | [ -1.78, 10.46] | 92.03% | [-4.85, 4.85] | 56.95% | 1.000 | 9346.00 season2 | -5.83 | [-11.23, -0.12] | 97.77% | [-4.85, 4.85] | 35.51% | 1.000 | 7367.00 species1:index500 | -9.23 | [-34.47, 16.99] | 76.62% | [-4.85, 4.85] | 23.65% | 1.000 | 5572.00 species1:season1 | -3.86 | [ -9.98, 2.12] | 90.00% | [-4.85, 4.85] | 62.60% | 1.000 | 10148.00 species1:season2 | -1.23 | [ -6.65, 4.31] | 66.78% | [-4.85, 4.85] | 92.09% | 1.000 | 10886.00 plot(p_direction(neutral.brm), stack=FALSE) #plot(model_parameters(neutral.brm, effects = &quot;all&quot;, component = &quot;conditional&quot;)) plot(conditional_effects(neutral.brm, effects = &quot;index500:species&quot;)) 6.4.3 Bayesian models - phylogenetic alpha set.seed(123) phylo.brm &lt;-brm(phylo ~ species + index500 + season + + species:index500 + species:season + (1|animal) + (1|sampling_site), data=diversity.data, family=gaussian(), chains = 3, iter = 3000, warmup = 1000) Compiling Stan program... Start sampling SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 1). Chain 1: Chain 1: Gradient evaluation took 0.000134 seconds Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.34 seconds. Chain 1: Adjust your expectations accordingly! Chain 1: Chain 1: Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 1: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 1: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 1: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 1: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 1: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 1: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 1: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 1: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 1: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) Chain 1: Chain 1: Elapsed Time: 0.905 seconds (Warm-up) Chain 1: 1.65 seconds (Sampling) Chain 1: 2.555 seconds (Total) Chain 1: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 2). Chain 2: Chain 2: Gradient evaluation took 3.3e-05 seconds Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.33 seconds. Chain 2: Adjust your expectations accordingly! Chain 2: Chain 2: Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 2: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 2: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 2: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 2: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 2: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 2: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 2: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 2: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 2: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) Chain 2: Chain 2: Elapsed Time: 0.833 seconds (Warm-up) Chain 2: 1.072 seconds (Sampling) Chain 2: 1.905 seconds (Total) Chain 2: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 3). Chain 3: Chain 3: Gradient evaluation took 3.7e-05 seconds Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.37 seconds. Chain 3: Adjust your expectations accordingly! Chain 3: Chain 3: Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 3: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 3: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 3: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 3: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 3: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 3: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 3: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 3: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 3: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) Chain 3: Chain 3: Elapsed Time: 0.883 seconds (Warm-up) Chain 3: 1.614 seconds (Sampling) Chain 3: 2.497 seconds (Total) Chain 3: #assessing model fit plot(phylo.brm) #pairs(phylo.brm) #posterior predictive check pp_check(phylo.brm) Using 10 posterior draws for ppc type &#39;dens_overlay&#39; by default. summary(phylo.brm) Family: gaussian Links: mu = identity; sigma = identity Formula: phylo ~ species + index500 + season + +species:index500 + species:season + (1 | animal) + (1 | sampling_site) Data: diversity.data (Number of observations: 155) Draws: 3 chains, each with iter = 3000; warmup = 1000; thin = 1; total post-warmup draws = 6000 Multilevel Hyperparameters: ~animal (Number of levels: 97) Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sd(Intercept) 0.35 0.21 0.02 0.77 1.00 1179 2193 ~sampling_site (Number of levels: 21) Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sd(Intercept) 0.48 0.20 0.10 0.91 1.00 1223 1107 Regression Coefficients: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS Intercept 5.74 0.32 5.12 6.40 1.00 3638 2763 species1 0.88 0.32 0.23 1.47 1.00 2982 2896 index500 -1.33 0.71 -2.77 0.02 1.00 3675 3019 season1 0.29 0.16 -0.01 0.59 1.00 6615 4454 season2 -0.20 0.14 -0.48 0.08 1.00 7280 4663 species1:index500 0.53 0.70 -0.83 2.00 1.00 2869 3185 species1:season1 -0.40 0.16 -0.72 -0.09 1.00 5703 4413 species1:season2 0.12 0.14 -0.15 0.40 1.00 5491 4121 Further Distributional Parameters: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sigma 1.22 0.09 1.04 1.41 1.00 2180 3030 Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS and Tail_ESS are effective sample size measures, and Rhat is the potential scale reduction factor on split chains (at convergence, Rhat = 1). describe_posterior(phylo.brm) Summary of Posterior Distribution Parameter | Median | 95% CI | pd | ROPE | % in ROPE | Rhat | ESS -------------------------------------------------------------------------------------------------- (Intercept) | 5.74 | [ 5.12, 6.40] | 100% | [-0.18, 0.18] | 0% | 1.002 | 3551.00 species1 | 0.89 | [ 0.23, 1.47] | 99.33% | [-0.18, 0.18] | 0% | 1.002 | 2896.00 index500 | -1.31 | [-2.77, 0.02] | 97.28% | [-0.18, 0.18] | 1.89% | 1.003 | 3544.00 season1 | 0.29 | [-0.01, 0.59] | 97.12% | [-0.18, 0.18] | 23.11% | 1.001 | 6553.00 season2 | -0.20 | [-0.48, 0.08] | 92.30% | [-0.18, 0.18] | 43.81% | 1.002 | 7236.00 species1:index500 | 0.51 | [-0.83, 2.00] | 77.87% | [-0.18, 0.18] | 17.42% | 1.002 | 2826.00 species1:season1 | -0.40 | [-0.72, -0.09] | 99.45% | [-0.18, 0.18] | 5.51% | 1.000 | 5584.00 species1:season2 | 0.12 | [-0.15, 0.40] | 80.85% | [-0.18, 0.18] | 66.79% | 1.001 | 5439.00 plot(p_direction(phylo.brm), stack=FALSE) #conditional_effects(phylo.brm) plot(conditional_effects(phylo.brm, effects = &quot;index500:species&quot;)) 6.4.4 Bayesian models - functional (distillr-based) alpha set.seed(123) func.brm &lt;-brm(func ~ species + index500 + season + + species:index500 + species:season + (1|animal), data=diversity.data, family=gaussian(), chains = 3, iter = 3000, warmup = 1000, control = list(adapt_delta = 0.9)) Compiling Stan program... Start sampling SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 1). Chain 1: Chain 1: Gradient evaluation took 9.9e-05 seconds Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.99 seconds. Chain 1: Adjust your expectations accordingly! Chain 1: Chain 1: Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 1: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 1: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 1: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 1: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 1: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 1: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 1: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 1: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 1: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) Chain 1: Chain 1: Elapsed Time: 1.806 seconds (Warm-up) Chain 1: 1.082 seconds (Sampling) Chain 1: 2.888 seconds (Total) Chain 1: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 2). Chain 2: Chain 2: Gradient evaluation took 2.6e-05 seconds Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.26 seconds. Chain 2: Adjust your expectations accordingly! Chain 2: Chain 2: Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 2: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 2: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 2: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 2: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 2: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 2: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 2: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 2: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 2: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) Chain 2: Chain 2: Elapsed Time: 1.835 seconds (Warm-up) Chain 2: 1.096 seconds (Sampling) Chain 2: 2.931 seconds (Total) Chain 2: SAMPLING FOR MODEL &#39;anon_model&#39; NOW (CHAIN 3). Chain 3: Chain 3: Gradient evaluation took 2.6e-05 seconds Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.26 seconds. Chain 3: Adjust your expectations accordingly! Chain 3: Chain 3: Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) Chain 3: Iteration: 300 / 3000 [ 10%] (Warmup) Chain 3: Iteration: 600 / 3000 [ 20%] (Warmup) Chain 3: Iteration: 900 / 3000 [ 30%] (Warmup) Chain 3: Iteration: 1001 / 3000 [ 33%] (Sampling) Chain 3: Iteration: 1300 / 3000 [ 43%] (Sampling) Chain 3: Iteration: 1600 / 3000 [ 53%] (Sampling) Chain 3: Iteration: 1900 / 3000 [ 63%] (Sampling) Chain 3: Iteration: 2200 / 3000 [ 73%] (Sampling) Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) Chain 3: Iteration: 2800 / 3000 [ 93%] (Sampling) Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) Chain 3: Chain 3: Elapsed Time: 1.911 seconds (Warm-up) Chain 3: 1.12 seconds (Sampling) Chain 3: 3.031 seconds (Total) Chain 3: #assessing model fit plot(func.brm) #pairs(func.brm) #posterior predictive check pp_check(func.brm) Using 10 posterior draws for ppc type &#39;dens_overlay&#39; by default. summary(func.brm) Family: gaussian Links: mu = identity; sigma = identity Formula: func ~ species + index500 + season + +species:index500 + species:season + (1 | animal) Data: diversity.data (Number of observations: 155) Draws: 3 chains, each with iter = 3000; warmup = 1000; thin = 1; total post-warmup draws = 6000 Multilevel Hyperparameters: ~animal (Number of levels: 97) Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sd(Intercept) 0.02 0.01 0.00 0.05 1.00 970 1878 Regression Coefficients: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS Intercept 1.45 0.01 1.42 1.47 1.00 8637 4269 species1 0.03 0.01 0.01 0.06 1.00 5402 4159 index500 -0.05 0.03 -0.10 0.01 1.00 8038 4946 season1 0.02 0.01 0.00 0.04 1.00 8103 5254 season2 -0.02 0.01 -0.03 0.00 1.00 8401 4900 species1:index500 0.02 0.03 -0.04 0.08 1.00 4917 4536 species1:season1 -0.03 0.01 -0.04 -0.01 1.00 8323 4978 species1:season2 0.02 0.01 -0.00 0.03 1.00 8835 5402 Further Distributional Parameters: Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS sigma 0.07 0.01 0.06 0.09 1.00 1702 3072 Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS and Tail_ESS are effective sample size measures, and Rhat is the potential scale reduction factor on split chains (at convergence, Rhat = 1). describe_posterior(func.brm) Summary of Posterior Distribution Parameter | Median | 95% CI | pd | ROPE | % in ROPE | Rhat | ESS -------------------------------------------------------------------------------------------------- (Intercept) | 1.45 | [ 1.42, 1.47] | 100% | [-0.01, 0.01] | 0% | 1.000 | 8513.00 species1 | 0.03 | [ 0.01, 0.06] | 99.28% | [-0.01, 0.01] | 2.23% | 1.000 | 5378.00 index500 | -0.05 | [-0.10, 0.01] | 96.05% | [-0.01, 0.01] | 5.72% | 1.000 | 7892.00 season1 | 0.02 | [ 0.00, 0.04] | 98.07% | [-0.01, 0.01] | 13.12% | 1.000 | 8090.00 season2 | -0.02 | [-0.03, 0.00] | 97.12% | [-0.01, 0.01] | 20.86% | 1.000 | 8307.00 species1:index500 | 0.02 | [-0.04, 0.08] | 76.25% | [-0.01, 0.01] | 20.47% | 1.000 | 4899.00 species1:season1 | -0.03 | [-0.04, -0.01] | 99.75% | [-0.01, 0.01] | 1.40% | 1.000 | 8280.00 species1:season2 | 0.01 | [ 0.00, 0.03] | 95.87% | [-0.01, 0.01] | 23.65% | 1.000 | 8850.00 plot(p_direction(func.brm), stack=FALSE) conditions &lt;- data.frame(season = c(&#39;spring-summer&#39;, &#39;autumn&#39;, &#39;winter&#39;)) plot(conditional_effects(func.brm, effects = &quot;index500:species&quot;, conditions = conditions)) plot(conditional_effects(func.brm, effects = &quot;species:season&quot;)) 6.5 Neutral beta diversity #neutral beta div beta_q1n &lt;-hilldiv2::hillpair(genome_counts, q=1, metric=&quot;S&quot;) #neutral beta diversity PERMANOVA sample_metadata_adonis &lt;- sample_metadata %&gt;% filter(sample %in% labels(beta_q1n)) %&gt;% arrange(sample) %&gt;% #mutate(location=paste0(round(longitude,2),&quot;_&quot;,round(latitude,2))) %&gt;% select(sample,species,sex,development,area_type,macroarea,season) %&gt;% select_if(~ length(unique(.)) &gt; 1) %&gt;% #remove columns with all-identical values column_to_rownames(var = &quot;sample&quot;) %&gt;% as.data.frame() adonis2(formula=beta_q1n ~ ., data=sample_metadata_adonis[labels(beta_q1n),], permutations=999) %&gt;% as.matrix() %&gt;% print() Df SumOfSqs R2 F Pr(&gt;F) species 1 12.4725698 0.152272893 42.099216 0.001 sex 1 0.5244422 0.006402717 1.770173 0.025 development 3 1.3842570 0.016899871 1.557448 0.002 area_type 2 2.4548253 0.029970034 4.142940 0.001 macroarea 12 13.7080934 0.167356934 3.855794 0.001 season 2 1.5924345 0.019441432 2.687507 0.001 Residual 168 49.7727024 0.607656120 NA NA Total 189 81.9093246 1.000000000 NA NA 6.5.1 Beta diversity by species and urbanization beta_q1n_nmds &lt;- beta_q1n %&gt;% metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %&gt;% vegan::scores() %&gt;% as_tibble(., rownames = &quot;sample&quot;) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) Run 0 stress 0.1016318 Run 1 stress 0.1012781 ... New best solution ... Procrustes: rmse 0.009391564 max resid 0.02171706 Run 2 stress 0.1015965 ... Procrustes: rmse 0.009314284 max resid 0.02237689 Run 3 stress 0.1013571 ... Procrustes: rmse 0.004290812 max resid 0.01881703 Run 4 stress 0.101292 ... Procrustes: rmse 0.003753977 max resid 0.01069427 Run 5 stress 0.1012824 ... Procrustes: rmse 0.004770538 max resid 0.01430988 Run 6 stress 0.1012654 ... New best solution ... Procrustes: rmse 0.002893324 max resid 0.0112937 Run 7 stress 0.1013507 ... Procrustes: rmse 0.003631289 max resid 0.01374934 Run 8 stress 0.1016306 ... Procrustes: rmse 0.009317477 max resid 0.0216053 Run 9 stress 0.1012915 ... Procrustes: rmse 0.002055849 max resid 0.01071861 Run 10 stress 0.1013087 ... Procrustes: rmse 0.003538692 max resid 0.01686552 Run 11 stress 0.1015959 ... Procrustes: rmse 0.009336227 max resid 0.02351447 Run 12 stress 0.1016114 ... Procrustes: rmse 0.009660027 max resid 0.02015117 Run 13 stress 0.1012747 ... Procrustes: rmse 0.00172592 max resid 0.00877539 ... Similar to previous best Run 14 stress 0.1013062 ... Procrustes: rmse 0.00335658 max resid 0.01678062 Run 15 stress 0.101373 ... Procrustes: rmse 0.006862742 max resid 0.03148474 Run 16 stress 0.101329 ... Procrustes: rmse 0.002829427 max resid 0.01363587 Run 17 stress 0.1016387 ... Procrustes: rmse 0.009508256 max resid 0.02033701 Run 18 stress 0.1013241 ... Procrustes: rmse 0.002904717 max resid 0.0165693 Run 19 stress 0.1013046 ... Procrustes: rmse 0.003282338 max resid 0.01665303 Run 20 stress 0.1013203 ... Procrustes: rmse 0.002335269 max resid 0.01503414 *** Best solution repeated 1 times beta_q1n_nmds %&gt;% group_by(species) %&gt;% filter(sample !=&quot;EHI00420&quot;) %&gt;% #remove outliers mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=area_type, shape=species, label=sample)) + scale_color_manual(values=area_colors) + geom_point(size=2.5) + #geom_text(hjust=2, vjust=0) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Species&quot;), shape=guide_legend(title=&quot;Area type&quot;)) ### Beta diversity by species and season beta_q1n_nmds %&gt;% group_by(species) %&gt;% filter(sample !=&quot;EHI00420&quot;) %&gt;% #remove outliers mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=season, shape=species)) + scale_color_manual(values=season_colors) + geom_point(size=2.5) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Species&quot;), shape=guide_legend(title=&quot;Season&quot;)) 6.5.2 Beta diversity by species and sex beta_q1n_nmds %&gt;% group_by(species) %&gt;% filter(sample !=&quot;EHI00420&quot;) %&gt;% #remove outliers mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=sex, shape=species)) + geom_point(size=2.5) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Species&quot;), shape=guide_legend(title=&quot;Sex&quot;)) 6.5.3 Beta diversity by species and development beta_q1n_nmds %&gt;% group_by(species) %&gt;% filter(sample !=&quot;EHI00420&quot;) %&gt;% #remove outliers mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=development, shape=species)) + geom_point(size=2.5) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Species&quot;), shape=guide_legend(title=&quot;Development&quot;)) "],["functional-analyses.html", "Chapter 7 Functional analyses 7.1 Data preparation 7.2 Genome-specific GIFT profiles 7.3 Element-level community-averaged GIFT profiles 7.4 Function-level community-averaged GIFT profiles 7.5 Domain-level", " Chapter 7 Functional analyses 7.1 Data preparation tss &lt;- function(abund){sweep(abund, 2, colSums(abund), FUN=&quot;/&quot;)} genome_counts &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) genome_kegg &lt;- genome_kegg %&gt;% column_to_rownames(var=&quot;genome&quot;) genome_gifts &lt;- genome_gifts %&gt;% column_to_rownames(var=&quot;genome&quot;) #Get list of present MAGs present_MAGs &lt;- genome_counts %&gt;% filter(rowSums(.[, -1]) != 0) %&gt;% rownames() #Align distillr annotations with present MAGs and remove all-zero and all-one traits present_MAGs &lt;- present_MAGs[present_MAGs %in% rownames(genome_gifts)] genome_gifts_filt &lt;- genome_gifts[present_MAGs,] %&gt;% select_if(~!all(. == 0)) %&gt;% #remove all-zero modules select_if(~!all(. == 1)) #remove all-one modules GIFTs_elements &lt;- genome_gifts_filt #Aggregate element-level GIFTs into the function level GIFTs_functions &lt;- to.functions(GIFTs_elements,GIFT_db) #Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs GIFTs_domains &lt;- to.domains(GIFTs_functions,GIFT_db) #Get overall metabolic capacity indices per MAG (at the domain level) rowMeans(GIFTs_functions) # averaged at the function level (each function is weighed equally) rowMeans(GIFTs_domains) # averaged at the domain level (each domain is weighed equally) #Get community-weighed average GIFTs per sample # GIFTs_elements_community &lt;- to.community(GIFTs_elements,genome_counts,GIFT_db) # GIFTs_functions_community &lt;- to.community(GIFTs_functions,genome_counts,GIFT_db) # GIFTs_domains_community &lt;- to.community(GIFTs_domains,genome_counts,GIFT_db) GIFTs_elements_community &lt;- genome_counts %&gt;% tss() %&gt;% to.community(GIFTs_elements,.,GIFT_db) GIFTs_functions_community &lt;- genome_counts %&gt;% tss() %&gt;% to.community(GIFTs_functions,.,GIFT_db) GIFTs_domains_community &lt;- genome_counts %&gt;% tss() %&gt;% to.community(GIFTs_domains,.,GIFT_db) GIFTs_elements_community %&gt;% rowMeans() %&gt;% as_tibble(., rownames = &quot;sample&quot;) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% group_by(species) %&gt;% summarise(MCI = mean(value), sd = sd(value)) # A tibble: 2 × 3 species MCI sd &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Sciurus carolinensis 0.297 0.0108 2 Sciurus vulgaris 0.327 0.0302 GIFTs_functions_community %&gt;% rowMeans() %&gt;% as_tibble(., rownames = &quot;sample&quot;) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% group_by(species) %&gt;% summarise(MCI = mean(value), sd = sd(value)) # A tibble: 2 × 3 species MCI sd &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Sciurus carolinensis 0.311 0.0117 2 Sciurus vulgaris 0.327 0.0375 GIFTs_domains_community %&gt;% rowMeans() %&gt;% as_tibble(., rownames = &quot;sample&quot;) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% group_by(species) %&gt;% summarise(MCI = mean(value), sd = sd(value)) # A tibble: 2 × 3 species MCI sd &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Sciurus carolinensis 0.325 0.0139 2 Sciurus vulgaris 0.324 0.0512 merge_gift &lt;- GIFTs_domains_community %&gt;% as.data.frame() %&gt;% rownames_to_column(., &quot;sample&quot;) %&gt;% merge(., sample_metadata, by=&quot;sample&quot;) 7.2 Genome-specific GIFT profiles GIFTs_elements %&gt;% as_tibble(., rownames = &quot;MAG&quot;) %&gt;% reshape2::melt() %&gt;% rename(Code_element = variable, GIFT = value) %&gt;% inner_join(GIFT_db,by=&quot;Code_element&quot;) %&gt;% ggplot(., aes(x=Code_element, y=MAG, fill=GIFT, group=Function))+ geom_tile()+ scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_fill_gradientn(limits = c(0,1), colours=brewer.pal(7, &quot;YlGnBu&quot;))+ facet_grid(. ~ Function, scales = &quot;free&quot;, space = &quot;free&quot;)+ theme_grey(base_size=8)+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90)) Using MAG as id variables Warning in inner_join(., GIFT_db, by = &quot;Code_element&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 13497 of `x` matches multiple rows in `y`. ℹ Row 1 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. 7.3 Element-level community-averaged GIFT profiles GIFTs_elements_community %&gt;% reshape2::melt() %&gt;% rename(sample = Var1, Code_element = Var2, GIFT = value) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% left_join(GIFT_db,by=&quot;Code_element&quot;) %&gt;% ggplot(., aes(x=Code_element, y=sample, fill=GIFT))+ geom_tile()+ scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_fill_gradientn(colours=brewer.pal(7, &quot;YlGnBu&quot;))+ theme_grey(base_size=8)+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),strip.text.x = element_text(angle = 90)) + facet_wrap(~species, scales=&quot;free&quot;) Warning in left_join(., GIFT_db, by = &quot;Code_element&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ℹ Row 1521 of `x` matches multiple rows in `y`. ℹ Row 1 of `y` matches multiple rows in `x`. ℹ If a many-to-many relationship is expected, set `relationship = &quot;many-to-many&quot;` to silence this warning. GIFTs_elements_nmds &lt;- GIFTs_elements_community %&gt;% dist() %&gt;% metaMDS(.,trymax = 500, k=2, verbosity=FALSE) %&gt;% vegan::scores() %&gt;% as_tibble(., rownames = &quot;sample&quot;) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) Warning in metaMDS(., trymax = 500, k = 2, verbosity = FALSE): stress is (nearly) zero: you may have insufficient data squirrel_colors &lt;- c(&quot;#999999&quot;, &quot;#cc3333&quot;) GIFTs_elements_nmds %&gt;% filter(!(sample==&quot;EHI00420&quot;)) %&gt;% #remove outlier group_by(species) %&gt;% mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=species, shape=area_type, label=sample)) + scale_color_manual(values=squirrel_colors) + geom_point(size=2.5) + #geom_text(hjust=2, vjust=0) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Species&quot;), shape=guide_legend(title=&quot;Area type&quot;)) 7.4 Function-level community-averaged GIFT profiles # sample_sort &lt;- sample_table %&gt;% # select(sample,species,Area_type) %&gt;% # arrange(species,Area_type) %&gt;% # pull() GIFTs_functions_community %&gt;% reshape2::melt() %&gt;% rename(sample = Var1, Code_function = Var2, GIFT = value) %&gt;% left_join(GIFT_db,by = join_by(Code_function == Code_function)) %&gt;% left_join(sample_metadata, by = join_by(sample == sample)) %&gt;% #mutate(sample=factor(Sample, levels = sample_sort)) %&gt;% ggplot(., aes(x=Function, y=sample, fill=GIFT))+ geom_tile()+ scale_y_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+ scale_fill_gradientn(colours=brewer.pal(7, &quot;YlGnBu&quot;))+ facet_grid(species~., scales=&quot;free&quot;) + theme_grey(base_size=8)+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_blank(), strip.text.x = element_text(angle = 90)) species.df &lt;- sample_metadata %&gt;% select(sample, species, animal) #ERROR, needs fixing # GIFTs_functions_community_tt &lt;- GIFTs_functions_community %&gt;% # as.data.frame() %&gt;% # rownames_to_column(&quot;sample&quot;) %&gt;% # left_join(., species.df, by = join_by(sample == sample)) %&gt;% # select(-sample) %&gt;% # pivot_longer(-c(species, animal), names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% # group_by(trait) %&gt;% # mutate(model_result = list(lmerTest::lmer(value ~ species + (1 | animal)))) %&gt;% # ungroup() %&gt;% # select(trait,model_result) %&gt;% # unique() %&gt;% # mutate(estimate = map_dbl(model_result, ~broom.mixed::tidy(.) %&gt;% filter(term == &quot;speciesSciuruscarolinensis&quot;) %&gt;% pull(estimate))) %&gt;% # mutate(p_value = map_dbl(model_result, ~broom.mixed::tidy(.) %&gt;% filter(term == &quot;speciesSciuruscarolinensis&quot;) %&gt;% pull(p.value))) %&gt;% # mutate(p_value_adj = p.adjust(p_value, method = &quot;bonferroni&quot;)) %&gt;% # left_join(GIFT_db %&gt;% select(Code_function,Function) %&gt;% unique(),by=join_by(trait==Code_function)) %&gt;% # rename(id=trait,trait=Function) %&gt;% # select(id,trait, estimate, p_value_adj) # # GIFTs_functions_community_tt %&gt;% tt() |&gt; # style_tt( # i = which(GIFTs_functions_community_tt$estimate &lt; 0 &amp; GIFTs_functions_community_tt$p_value_adj &lt; 0.05), # background = &quot;#E5D5B1&quot;) |&gt; # style_tt( # i = which(GIFTs_functions_community_tt$estimate &gt; 0 &amp; GIFTs_functions_community_tt$p_value_adj &lt; 0.05), # background = &quot;#B7BCCE&quot;) GIFTs_functions_community %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;sample&quot;) %&gt;% left_join(., species.df, by = join_by(sample == sample)) %&gt;% select(-animal) %&gt;% pivot_longer(-c(sample, species), names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trait = case_when( trait %in% GIFT_db$Code_function ~ GIFT_db$Function[match(trait, GIFT_db$Code_function)], TRUE ~ trait)) %&gt;% mutate(trait=factor(trait,levels=unique(GIFT_db$Function))) %&gt;% ggplot(aes(x=value, y=species, group=species, fill=species, color=species)) + geom_boxplot() + scale_color_manual(name=&quot;species&quot;, breaks=c(&quot;Sciurus carolinensis&quot;,&quot;Sciurus vulgaris&quot;), labels=c(&quot;Sciurus carolinensis&quot;,&quot;Sciurus vulgaris&quot;), values=c(&quot;#999999&quot;, &quot;#cc3333&quot;)) + scale_fill_manual(name=&quot;species&quot;, breaks=c(&quot;Sciurus carolinensis&quot;,&quot;Sciurus vulgaris&quot;), labels=c(&quot;Sciurus carolinensis&quot;,&quot;Sciurus vulgaris&quot;), values=c(&quot;#bfbfbf&quot;, &quot;#db7070&quot;)) + facet_grid(trait ~ ., space=&quot;free&quot;, scales=&quot;free&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_blank(), strip.text.y = element_text(angle = 0)) + labs(y=&quot;Traits&quot;,x=&quot;Metabolic capacity index&quot;) 7.5 Domain-level squirrel_colors &lt;- c(&quot;#999999&quot;, &quot;#cc3333&quot;) #Biosynthesis by species biosynth.species &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Biosynthesis&quot;, color = &quot;species&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=squirrel_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Biosynthesis functions&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) #Degradation by species degradation.species &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Degradation&quot;, color = &quot;species&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=squirrel_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Degradation functions&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) #Structure by species structure.species &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Structure&quot;, color = &quot;species&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=squirrel_colors) + scale_fill_manual(values=paste0(squirrel_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Structural functions&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank()) sp.legend &lt;- get_legend(biosynth.species) ggarrange(biosynth.species, degradation.species, structure.species, #+ rremove(&quot;x.text&quot;), legend.grob = sp.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) ### Differences in bacterial functional capacity #grid.arrange(arrangeGrob(p1, p5,p3, p4, ncol = 2)) merge_gift$area_type &lt;-factor(merge_gift$area_type, levels = c(&quot;rural&quot;, &quot;suburban&quot;, &quot;urban&quot;)) area_colors &lt;- c(&quot;#76b183&quot;,&quot;#d57d2c&quot;,&quot;#6b7398&quot;) #Biosynthesis by species*area_type biosynth.area &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Biosynthesis&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Biosynthesis&quot;) + theme( legend.position = &quot;right&quot;, legend.box = &quot;vertical&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Area type&quot;), fill=&quot;none&quot;) #Degradation by species*area_type degradation.area &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Degradation&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Degradation&quot;) + theme( legend.position = &quot;right&quot;, legend.box = &quot;vertical&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Area type&quot;), fill=&quot;none&quot;) #Structure by species*area_type structure.area &lt;- merge_gift %&gt;% ggboxplot(., x = &quot;species&quot;, y = &quot;Structure&quot;, color = &quot;area_type&quot;, fill=&quot;white&quot;, add=&quot;jitter&quot;) + scale_color_manual(values=area_colors) + scale_fill_manual(values=paste0(area_colors)) + stat_compare_means() + theme_classic() + labs(y = &quot;Structure&quot;) + theme( legend.position = &quot;right&quot;, legend.box = &quot;vertical&quot;, axis.title.x = element_blank()) + guides(color=guide_legend(title=&quot;Area type&quot;), fill=&quot;none&quot;) area.legend &lt;- get_legend(biosynth.area) ggarrange(biosynth.area, degradation.area, structure.area, #+ rremove(&quot;x.text&quot;), legend.grob = area.legend, legend=&quot;right&quot;, common.legend = TRUE, #labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), ncol = 1, nrow = 3) "],["hmsc-setup.html", "Chapter 8 HMSC setup 8.1 Prepare input for Hmsc 8.2 Define formulas of the Hmsc model 8.3 Define and Hmsc models 8.4 Define MCMC 8.5 Generate Hmsc executables 8.6 Fit Hmsc models (in Mjolnir HPC) 8.7 Assess chain convergence", " Chapter 8 HMSC setup rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) singlem &lt;- read.csv(&quot;data/singlem.csv&quot;,sep=&quot;;&quot;,header=T) 8.1 Prepare input for Hmsc sample_metadata &lt;- sample_metadata %&gt;% right_join(singlem, by = join_by(sample == sample)) %&gt;% filter(development==&quot;Adult&quot;) %&gt;% #remove juveniles, nursing and pregnant females filter(est_mapp&gt;0.8) #remove 5 samples with low DAMR selected_genomes0 &lt;- sample_metadata %&gt;% pull(sample) # Subset by prevalence (present in more than 5 samples) selected_genomes1 &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(any_of(selected_genomes0)) %&gt;% filter(rowSums(across(starts_with(&quot;EHI&quot;)) != 0) &gt;= 5) %&gt;% rownames() # Subset by minimum representation of 1% relative abundance in at least 5 samples selected_genomes2 &lt;- genome_counts %&gt;% filter(genome %in% selected_genomes1) %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% hilldiv2::tss() %&gt;% as.data.frame() %&gt;% filter(rowSums(across(starts_with(&quot;EHI&quot;)) &gt;= 0.01) &gt;= 5) %&gt;% rownames() # Subset genome metadata genome_metadata_subset &lt;- genome_metadata %&gt;% filter(genome %in% selected_genomes2) # Random effects data (study design) StudyDesign &lt;- sample_metadata %&gt;% select(sample,animal,sampling_site) %&gt;% mutate(sampling_site = factor(sampling_site)) %&gt;% mutate(animal = factor(animal)) %&gt;% column_to_rownames(&quot;sample&quot;) # Genome count table (quantitative community data) YData &lt;- read_counts %&gt;% filter(genome %in% selected_genomes2) %&gt;% #subset genomes mutate(across(where(is.numeric), ~ . +1 )) %&gt;% #add +1 pseudocount to remove zeros mutate(across(where(is.numeric), ~ . / (genome_metadata_subset$length / 150) )) %&gt;% #transform to genome counts mutate(across(where(is.numeric), ~ log(.) )) %&gt;% #log-transform column_to_rownames(&quot;genome&quot;) %&gt;% select(all_of(row.names(StudyDesign))) %&gt;% #filter only faecal samples as.data.frame() %&gt;% t() # transpose # Fixed effects data (explanatory variables) XData &lt;- sample_metadata %&gt;% select(sample,species,index500,season) %&gt;% mutate(logseqdepth=read_counts %&gt;% #total log-sequencing depth select(all_of(row.names(StudyDesign))) %&gt;% colSums() %&gt;% log() ) %&gt;% mutate(index500 = index500) %&gt;% mutate(species = factor(species, levels=c(&quot;Sciurus vulgaris&quot;,&quot;Sciurus carolinensis&quot;))) %&gt;% mutate(season = factor(season, levels=c(&quot;spring-summer&quot;,&quot;autumn&quot;,&quot;winter&quot;))) %&gt;% column_to_rownames(&quot;sample&quot;) # Genome trait data TrData &lt;- genome_gifts %&gt;% filter(genome %in% selected_genomes2) %&gt;% #subset genomes arrange(match(genome, colnames(YData))) %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% to.functions(.,GIFT_db) %&gt;% as.data.frame() # Genome phylogeny PData &lt;- genome_tree 8.2 Define formulas of the Hmsc model # Fixed effects formula XFormula1 = ~species + index500 + season + logseqdepth XFormula2 = ~species + index500 + season + logseqdepth + species*index500 XFormula3 = ~species + index500 + season + logseqdepth + species*season XFormula4 = ~species + index500 + season + logseqdepth + species*season + species*index500 # Study design rL.animal = HmscRandomLevel(units = levels(StudyDesign$animal)) rL.sampling_site = HmscRandomLevel(units = levels(StudyDesign$sampling_site)) 8.3 Define and Hmsc models #Define models model.1a = Hmsc(Y=YData, XData = XData, XFormula = XFormula1, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal), distr = &quot;normal&quot;, YScale = TRUE) model.1b = Hmsc(Y=YData, XData = XData, XFormula = XFormula1, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal, &quot;sampling_site&quot;=rL.sampling_site), distr = &quot;normal&quot;, YScale = TRUE) model.2a = Hmsc(Y=YData, XData = XData, XFormula = XFormula2, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal), distr = &quot;normal&quot;, YScale = TRUE) model.2b = Hmsc(Y=YData, XData = XData, XFormula = XFormula2, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal, &quot;sampling_site&quot;=rL.sampling_site), distr = &quot;normal&quot;, YScale = TRUE) model.3a = Hmsc(Y=YData, XData = XData, XFormula = XFormula3, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal), distr = &quot;normal&quot;, YScale = TRUE) model.3b = Hmsc(Y=YData, XData = XData, XFormula = XFormula3, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal, &quot;sampling_site&quot;=rL.sampling_site), distr = &quot;normal&quot;, YScale = TRUE) model.4a = Hmsc(Y=YData, XData = XData, XFormula = XFormula4, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal), distr = &quot;normal&quot;, YScale = TRUE) model.4b = Hmsc(Y=YData, XData = XData, XFormula = XFormula4, studyDesign = StudyDesign, phyloTree = PData, ranLevels = list(&quot;animal&quot;=rL.animal, &quot;sampling_site&quot;=rL.sampling_site), distr = &quot;normal&quot;, YScale = TRUE) #Save list of models as an R object. model_list = list(model.1a=model.1a,model.1b=model.1b,model.2a=model.2a,model.2b=model.2b,model.3a=model.3a,model.3b=model.3b, model.4a=model.4a,model.4b=model.4b) if (!dir.exists(&quot;hmsc&quot;)){dir.create(&quot;hmsc&quot;)} save(model_list, file = &quot;hmsc/hmsc.Rdata&quot;) Upload hmsc/hmsc.Rdata to the HPC respecting the directory structure. 8.4 Define MCMC # How often to sample the MCMC MCMC_samples_list = 250 # The number of MCMC steps between each recording sample MCMC_thin_list = c(1, 10) # The number of MCMC chains to use nChains = 4 8.5 Generate Hmsc executables The next chunk generates shell files for every combination of model, MCMC samples and MCMM thinning, ready to be launched as SLURM jobs. modelchains &lt;- expand.grid(model = names(model_list), sample = MCMC_samples_list, thin = MCMC_thin_list) if (!dir.exists(&quot;hmsc&quot;)){dir.create(&quot;hmsc&quot;)} for(i in c(1:nrow(modelchains))){ modelname=as.character(modelchains[i,1]) sample=modelchains[i,2] thin=modelchains[i,3] executablename &lt;- paste0(&quot;hmsc/exe_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.sh&quot;) fitname &lt;- paste0(&quot;hmsc/fit_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.Rdata&quot;) convname &lt;- paste0(&quot;hmsc/conv_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin,&quot;.Rdata&quot;) model &lt;- paste0(&#39;model_list$&#39;,modelname) psrf.beta.name &lt;- paste0(&quot;psrf.beta.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) psrf.gamma.name &lt;- paste0(&quot;psrf.gamma.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) psrf.rho.name &lt;- paste0(&quot;psrf.rho.&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) jobname &lt;- paste0(&quot;hmsc_&quot;,modelname,&quot;_&quot;,sample,&quot;_&quot;,thin) minutes &lt;- round(sample * thin * (ncol(YData)/50), 0) code &lt;- sprintf(&quot;#!/bin/bash #SBATCH --job-name=%s # Job name #SBATCH --nodes=1 #SBATCH --ntasks=4 # Run on 4 CPUs #SBATCH --mail-user=antton.alberdi@sund.ku.dk #SBATCH --mem=200gb # Job memory request #SBATCH --time=%d # In minutes # Activate conda environment module load mamba/1.3.1 if ! conda info --envs | grep -q hmsc; then mamba create -p ./hmsc/hmsc_env -y r-essentials r-base r-tidyverse r-Hmsc fi # Activate conda environment source activate ./hmsc/hmsc_env # Run R script Rscript -e &#39; library(tidyverse) library(Hmsc) # Load formulas and data load(\\&quot;hmsc/hmsc.Rdata\\&quot;) # Declare placeholders modelname = \\&quot;%s\\&quot; model = %s fitname = \\&quot;%s\\&quot; convname = \\&quot;%s\\&quot; sample = %d thin = %d nchains = %d # Run model fitting m = sampleMcmc(hM = model, samples = sample, thin = thin, adaptNf=rep(ceiling(0.4*sample*thin),model$nr), transient = ceiling(0.5*sample*thin), nChains = nchains, nParallel = nchains) # Assess chain convergence mpost = convertToCodaObject(m, spNamesNumbers = c(T,F), covNamesNumbers = c(T,F), Beta = TRUE, Gamma = TRUE, V = FALSE, Sigma = FALSE, Rho = TRUE, Eta = FALSE, Lambda = FALSE, Alpha = FALSE, Omega = FALSE, Psi = FALSE, Delta = FALSE) # Convert to CODA object # Fixed effects assign(paste0(\\&quot;psrf.beta.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Beta,multivariate=FALSE)$psrf) # Traits assign(paste0(\\&quot;psrf.gamma.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Gamma,multivariate=FALSE)$psrf) # Phylogeny assign(paste0(\\&quot;psrf.rho.\\&quot;, modelname,\\&quot;_\\&quot;,sample,\\&quot;_\\&quot;,thin), gelman.diag(mpost$Rho,multivariate=FALSE)$psrf) # Write convergence data save(%s, %s, %s, file=convname) # Save model fit object save(m, file=fitname) &#39; &quot;, jobname, minutes, modelname, model, fitname, convname, sample, thin, nChains, psrf.beta.name, psrf.gamma.name, psrf.rho.name) writeLines(code, executablename) } Upload the produced hmsc/exe_XXXXX.sh files to the HPC respecting the directory structure. 8.6 Fit Hmsc models (in Mjolnir HPC) Launch the SLURM jobs by using: # Submit all .sh files in the hmsc folder for jobfile in hmsc/exe_*.sh; do sbatch &quot;$jobfile&quot; done #Or launch them one by one only the ones you want to launch sbatch hmsc/exe_model1_250_10.sh sbatch hmsc/exe_model2_250_10.sh sbatch hmsc/exe_model3_250_10.sh sbatch hmsc/exe_model4_250_10.sh sbatch hmsc/exe_model5_250_1.sh sbatch hmsc/exe_model6_250_10.sh sbatch hmsc/exe_model7_250_10.sh sbatch hmsc/exe_model8_250_10.sh 8.7 Assess chain convergence Convergence diagnostic values substantially above 1 indicate lack of convergence. Values below 1.1 are considered good enough # Load all conv file available in the hmsc folder list.files(path = &quot;hmsc&quot;, pattern = &quot;^conv_&quot;, full.names = TRUE, include.dirs = TRUE) %&gt;% lapply(.,load,.GlobalEnv) # Create a merged psrf.beta (genome) plot ls() %&gt;% grep(&quot;^psrf\\\\.beta&quot;, ., value = TRUE) %&gt;% map_dfr(~ { mat &lt;- get(.x) data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %&gt;% rownames_to_column(var=&quot;parameter&quot;) %&gt;% mutate(model = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(1) %&gt;% gsub(&quot;psrf.beta.&quot;,&quot;&quot;,.)) %&gt;% mutate(sample = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(2)) %&gt;% #extract sample info from model name mutate(thin = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(3)) #extract thin info from model name }) %&gt;% ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) + geom_violin(fill=&quot;#b8d9e3&quot;, color=&quot;#328da8&quot;) + geom_jitter(alpha=0.3,size=0.2, color=&quot;#a8babf&quot;) + stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom=&quot;crossbar&quot;, width=0.2, color=&quot;orange&quot;) + geom_hline(yintercept=1.1, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + ylim(0.9,2)+ labs(x=&quot;Model chains&quot;,y=&quot;Parameter estimates&quot;)+ theme_classic()+ coord_flip() # Create a merged psrf.gamma (trait) plot ls() %&gt;% grep(&quot;^psrf\\\\.gamma&quot;, ., value = TRUE) %&gt;% map_dfr(~ { mat &lt;- get(.x) data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %&gt;% rownames_to_column(var=&quot;parameter&quot;) %&gt;% mutate(model = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(1) %&gt;% gsub(&quot;psrf.gamma.&quot;,&quot;&quot;,.)) %&gt;% mutate(sample = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(2)) %&gt;% #extract sample info from model name mutate(thin = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(3)) #extract thin info from model name }) %&gt;% ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) + geom_violin(fill=&quot;#b8d9e3&quot;, color=&quot;#328da8&quot;) + geom_jitter(alpha=0.3,size=0.2, color=&quot;#a8babf&quot;) + stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom=&quot;crossbar&quot;, width=0.2, color=&quot;orange&quot;) + geom_hline(yintercept=1.1, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + ylim(0.9,2)+ labs(x=&quot;Model chains&quot;,y=&quot;Parameter estimates&quot;)+ theme_classic()+ coord_flip() # Create a merged psrf.rho (phylogeny) plot ls() %&gt;% grep(&quot;^psrf\\\\.rho&quot;, ., value = TRUE) %&gt;% map_dfr(~ { mat &lt;- get(.x) data.frame(modelchain = .x, as.data.frame(mat, , stringsAsFactors = FALSE)) %&gt;% rownames_to_column(var=&quot;parameter&quot;) %&gt;% mutate(model = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(1) %&gt;% gsub(&quot;psrf.rho.&quot;,&quot;&quot;,.)) %&gt;% mutate(sample = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(2)) %&gt;% #extract sample info from model name mutate(thin = str_split(modelchain, &quot;_&quot;) %&gt;% map_chr(3)) #extract thin info from model name }) %&gt;% ggplot(.,aes(x=reorder(modelchain,-Point.est.,fun=function(x) {quantile(x, probs = 0.9)}),y=Point.est.)) + geom_violin(fill=&quot;#b8d9e3&quot;, color=&quot;#328da8&quot;) + geom_jitter(alpha=0.3,size=0.2, color=&quot;#a8babf&quot;) + stat_summary(fun=function(x) {quantile(x, probs = 0.9)}, geom=&quot;crossbar&quot;, width=0.2, color=&quot;orange&quot;) + geom_hline(yintercept=1.1, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + ylim(0.9,2)+ labs(x=&quot;Model chains&quot;,y=&quot;Parameter estimates&quot;)+ theme_classic()+ coord_flip() # Select modelchain of interest load(&quot;hmsc/fit_model.1a_250_10.Rdata&quot;) m1a.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.1b_250_10.Rdata&quot;) m1b.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.2a_250_10.Rdata&quot;) m2a.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.2b_250_10.Rdata&quot;) m2b.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.3a_250_10.Rdata&quot;) m3a.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.3b_250_10.Rdata&quot;) m3b.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.4a_250_10.Rdata&quot;) m4a.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() load(&quot;hmsc/fit_model.4b_250_10.Rdata&quot;) m4b.WAIC &lt;- computeWAIC(m, ghN = 10, byColumn = TRUE) %&gt;% sum() WAICsum &lt;- c(m1a.WAIC,m1b.WAIC,m2a.WAIC,m2b.WAIC,m3a.WAIC,m3b.WAIC,m4a.WAIC,m4b.WAIC) %&gt;% rbind() print(WAICsum) # print(WAICsum) # print(WAICmedian) "],["hmsc-analysis.html", "Chapter 9 HMSC analysis 9.1 Model list 9.2 Compute variance partitioning", " Chapter 9 HMSC analysis rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) 9.1 Model list # Select modelchain of interest load(&quot;hmsc/fit_model.4a_250_10.Rdata&quot;) levels.1a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.1b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.2a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.2b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.3a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.3b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.4a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.4b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;species:index500&quot;,&quot;species:season&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) 9.2 Compute variance partitioning # Compute variance partitioning varpart=computeVariancePartitioning(m) varpart$vals %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;variable&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(variable=factor(variable, levels=levels.4a)) %&gt;% group_by(variable) %&gt;% summarise(mean=mean(value)*100,sd=sd(value)*100) %&gt;% tt() tinytable_v2umdwud9h16zc9ckv1g .table td.tinytable_css_mh3il03ka9map0gvr8bo, .table th.tinytable_css_mh3il03ka9map0gvr8bo { border-bottom: solid 0.1em #d3d8dc; } variable mean sd species 25.348636 25.033380 index500 2.228784 3.025111 season 7.983225 4.612790 species:index500 2.112280 1.996825 species:season 8.459286 5.255216 logseqdepth 3.542316 2.300396 Random: animal 50.325473 25.344302 # Basal tree varpart_tree &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) #Varpart table varpart_table &lt;- varpart$vals %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;variable&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(variable=factor(variable, levels=rev(levels.4a))) %&gt;% mutate(genome=factor(genome, levels=rev(varpart_tree$tip.label))) #Phylums phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% varpart_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) colors_alphabetic &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% varpart_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() # Basal ggtree varpart_tree &lt;- varpart_tree %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add phylum colors next to the tree tips varpart_tree &lt;- gheatmap(varpart_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic)+ labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap varpart_tree &lt;- varpart_tree + new_scale_fill() # Add variance stacked barplot vertical_tree &lt;- varpart_tree + #scale_fill_manual(values=c(&quot;#34738f&quot;,&quot;#cccccc&quot;,&quot;#ed8a45&quot;,&quot;#b2b530&quot;,&quot;#be3e2b&quot;,&quot;#f6de6c&quot;,&quot;#83bb90&quot;))+ scale_fill_manual(values=c(&quot;#34738f&quot;,&quot;#cccccc&quot;,&quot;#ed8a45&quot;,&quot;#b2b530&quot;,&quot;#be3e2b&quot;,&quot;#83bb90&quot;,&quot;#f6de6c&quot;))+ #&quot;#122f3d&quot; geom_fruit( data=varpart_table, geom=geom_bar, mapping = aes(x=value, y=genome, fill=variable, group=variable), pwidth = 2, offset = 0.05, width= 1, orientation=&quot;y&quot;, stat=&quot;identity&quot;)+ labs(fill=&quot;Variable&quot;) vertical_tree # Select desired support threshold support=0.9 negsupport=1-support # Basal tree postestimates_tree &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) #plotBeta(hM=m, post=getPostEstimate(hM=m, parName=&quot;Beta&quot;), param = &quot;Support&quot;, plotTree = TRUE, covNamesNumbers=c(1,0)) # Posterior estimate table post_beta &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome=factor(genome, levels=rev(postestimates_tree$tip.label))) %&gt;% mutate(value = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% mutate(value=factor(value, levels=c(&quot;Positive&quot;,&quot;Neutral&quot;,&quot;Negative&quot;))) %&gt;% pivot_wider(names_from = variable, values_from = value) %&gt;% # rename(intercept=2, # species.grey=3, # index500=4, # season.autumn=5, # season.winter=6, # logseqdepth=7, # species.grey_season.autumn=8, # species.grey_season.winter=9) %&gt;% # select(genome,builtup,species,season_autumn,season_winter, builtup_species,species_season_autumn,species_season_winter) %&gt;% #rename(intercept=2, sp_vulgaris=3, area_semi=4, area_urban=5, season_spring=6, season_winter=7, logseqdepth=8, sp_vulgarisxarea_semi=9, sp_vulgarisxarea_urban =10, sp_vulgarisxseason_spring=11, sp_vulgarisxseason_winter=12) %&gt;% #select(genome,sp_vulgaris,area_semi,area_urban,sp_vulgarisxarea_semi,sp_vulgarisxarea_urban,season_spring,season_winter,sp_vulgarisxseason_spring,sp_vulgarisxseason_winter) %&gt;% column_to_rownames(var=&quot;genome&quot;) #Phylums phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% postestimates_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) colors_alphabetic &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;) %&gt;% right_join(genome_metadata, by=join_by(phylum == phylum)) %&gt;% filter(genome %in% postestimates_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() # Basal ggtree postestimates_tree &lt;- postestimates_tree %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #Add phylum colors next to the tree tips postestimates_tree &lt;- gheatmap(postestimates_tree, phylum_colors, offset=-0.2, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic)+ labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap postestimates_tree &lt;- postestimates_tree + new_scale_fill() # Add posterior significant heatmap postestimates_tree &lt;- gheatmap(postestimates_tree, post_beta, offset=0, width=0.5, colnames=TRUE, colnames_position=&quot;top&quot;,colnames_angle=90, colnames_offset_y=1, hjust=0) + scale_fill_manual(values=c(&quot;#be3e2b&quot;,&quot;#f4f4f4&quot;,&quot;#b2b530&quot;))+ labs(fill=&quot;Trend&quot;) postestimates_tree + vexpand(.25, 1) # expand top #Compute the residual correlation matrix OmegaCor = computeAssociations(m) # Refernece tree (for sorting genomes) genome_tree_subset &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) #Co-occurrence matrix at the animal level supportLevel = 0.95 toPlot = ((OmegaCor[[1]]$support&gt;supportLevel) + (OmegaCor[[1]]$support&lt;(1-supportLevel))&gt;0)*OmegaCor[[1]]$mean matrix &lt;- toPlot %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;genome1&quot;) %&gt;% pivot_longer(!genome1, names_to = &quot;genome2&quot;, values_to = &quot;cor&quot;) %&gt;% mutate(genome1= factor(genome1, levels=genome_tree_subset$tip.label)) %&gt;% mutate(genome2= factor(genome2, levels=genome_tree_subset$tip.label)) %&gt;% ggplot(aes(x = genome1, y = genome2, fill = cor)) + geom_tile() + scale_fill_gradient2(low = &quot;#be3e2b&quot;, mid = &quot;#f4f4f4&quot;, high = &quot;#b2b530&quot;)+ theme_void() vtree &lt;- genome_tree_subset %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(.) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #create composite figure grid.arrange(grobs = list(vtree,matrix,vtree), layout_matrix = rbind(c(4,1,1,1,1,1,1,1,1,1,1,1), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2), c(3,2,2,2,2,2,2,2,2,2,2,2))) # Overall species prediction pred_species &lt;- constructGradient(m, focalVariable = &quot;species&quot;, non.focalVariables = 1, ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) %&gt;% as.data.frame() %&gt;% mutate(species=c(&quot;Sciurus vulgaris&quot;,&quot;Sciurus carolinensis&quot;)) %&gt;% pivot_longer(!species, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome = sub(&quot;(.*\\\\..*\\\\.)[^.]+.*&quot;, &quot;\\\\1&quot;, genome)) %&gt;% #remove iteration suffix mutate(genome = sub(&quot;\\\\.$&quot;, &quot;&quot;, genome)) pred_species %&gt;% pivot_wider(names_from = species, values_from = value) %&gt;% unnest(c(`Sciurus carolinensis`, `Sciurus vulgaris`)) %&gt;% mutate(diff_grey.red = `Sciurus carolinensis` - `Sciurus vulgaris`) %&gt;% select(genome, diff_grey.red) %&gt;% left_join(genome_metadata, by=join_by(genome==genome)) %&gt;% mutate(genome= factor(genome, levels=genome_tree_subset$tip.label)) %&gt;% ggplot(., aes(y=genome, x=diff_grey.red, fill=phylum, color=phylum)) + scale_color_manual(values=colors_alphabetic)+ geom_vline(xintercept = 0)+ scale_fill_manual(values=paste0(colors_alphabetic,&quot;80&quot;))+ geom_boxplot(outlier.shape = NA) + theme_classic() + theme(axis.text.y = element_blank()) gradient = c(0:100) gradientlength = length(gradient) # Overall urbanisation prediction pred_urban &lt;- constructGradient(m, focalVariable = &quot;index500&quot;, non.focalVariables = 1, ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) %&gt;% do.call(rbind,.) %&gt;% as.data.frame() %&gt;% mutate(index500=rep(gradient,1000)) %&gt;% pivot_longer(-index500, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome = sub(&quot;(.*\\\\..*\\\\.)[^.]+.*&quot;, &quot;\\\\1&quot;, genome)) %&gt;% #remove iteration suffix mutate(genome = sub(&quot;\\\\.$&quot;, &quot;&quot;, genome)) #remove iteration suffix pred_urban %&gt;% mutate(genome=factor(genome, levels=genome_tree_subset$tip.label)) %&gt;% group_by(index500,genome) %&gt;% summarise(mean=mean(value)) %&gt;% ggplot(., aes(y=genome, x=index500, fill=mean, color=mean)) + geom_tile() + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) + theme_classic()+ theme( axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) # Urbanisation Sciurus vulgaris prediction pred_urban_SciVu &lt;- constructGradient(m, focalVariable = &quot;index500&quot;, non.focalVariables = list(species=list(3,&quot;Sciurus vulgaris&quot;)), ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) # weights: 9 (4 variable) initial value 170.284905 final value 168.819259 converged # Urbanisation Sciurus carolinensis prediction pred_urban_SciCa &lt;- constructGradient(m, focalVariable = &quot;index500&quot;, non.focalVariables = list(species=list(3,&quot;Sciurus carolinensis&quot;)), ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) # weights: 9 (4 variable) initial value 170.284905 final value 168.819259 converged pred_urban_SciVu %&gt;% mutate(genome=factor(genome, levels=genome_tree_subset$tip.label)) %&gt;% group_by(index500,genome) %&gt;% summarise(mean=mean(value)) %&gt;% ggplot(., aes(y=genome, x=index500, fill=mean, color=mean)) + geom_tile() + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) + theme_classic()+ theme( axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
