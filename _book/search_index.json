[["joint-species-distribution-modelling---output-analysis.html", "Chapter 9 Joint Species Distribution Modelling - output analysis 9.1 Variance partitioning 9.2 Model fit 9.3 Correlations among bacteria 9.4 Association with host species 9.5 Microbiome composition predictions 9.6 Microbiome functional predictions", " Chapter 9 Joint Species Distribution Modelling - output analysis rm(list=ls()) #clear environment load(&quot;data/squirrels_data.Rdata&quot;) options(contrasts = c(&#39;contr.sum&#39;,&#39;contr.poly&#39;)) # Select desired support threshold support_threshold=0.9 negsupport_threshold=1-support_threshold # Select modelchain of interest load(&quot;hmsc/fit_model.3a_250_10.Rdata&quot;) levels.1a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.1b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.2a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.2b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.3a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.3b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) levels.4a &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;species:index500&quot;,&quot;species:season&quot;,&quot;logseqdepth&quot;,&quot;Random: animal&quot;) levels.4b &lt;- c(&quot;species&quot;,&quot;index500&quot;,&quot;season&quot;,&quot;logseqdepth&quot;,&quot;species:index500&quot;,&quot;species:season&quot;,&quot;Random: animal&quot;, &quot;Random: sampling_site&quot;) 9.1 Variance partitioning # Compute variance partitioning varpart=computeVariancePartitioning(m) varpart$vals %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;variable&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(variable=factor(variable, levels=levels.3a)) %&gt;% group_by(variable) %&gt;% summarise(mean=mean(value)*100,sd=sd(value)*100) %&gt;% tt() tinytable_ronymq1vm5350kyu3xrp .table td.tinytable_css_80sgqjc3uq9ywf3ug1fd, .table th.tinytable_css_80sgqjc3uq9ywf3ug1fd { border-bottom: solid 0.1em #d3d8dc; } variable mean sd species 27.912981 28.448176 index500 1.272544 2.046256 season 8.273125 5.025935 species:season 8.617260 5.298745 logseqdepth 3.573087 2.297375 Random: animal 50.351004 26.142128 # Basal tree varpart_tree &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) # Varpart table varpart_table &lt;- varpart$vals %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;variable&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(variable=factor(variable, levels=rev(levels.3a))) %&gt;% mutate(genome=factor(genome, levels=rev(varpart_tree$tip.label))) # Phylums phylums &lt;- genome_metadata %&gt;% filter(genome %in% varpart_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) # Basal ggtree varpart_tree &lt;- varpart_tree %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultrametric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** # Add phylum colors next to the tree tips varpart_tree &lt;- gheatmap(varpart_tree, phylums, offset=-0.2, width=0.1, colnames=FALSE) + scale_fill_manual(values=custom_colors)+ labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap varpart_tree &lt;- varpart_tree + new_scale_fill() # Add variance stacked barplot vertical_tree &lt;- varpart_tree + scale_fill_manual(values=c(&quot;#83bb90&quot;,&quot;#cccccc&quot;,&quot;#ed8a45&quot;,&quot;#b2b530&quot;,&quot;#be3e2b&quot;,&quot;#12738f&quot;,&quot;#f6de9c&quot;)) + #&quot;#122f3d&quot; geom_fruit( data=varpart_table, geom=geom_bar, mapping = aes(x=value, y=genome, fill=variable, group=variable), pwidth = 2, offset = 0.05, width= 1, orientation=&quot;y&quot;, stat=&quot;identity&quot;)+ labs(fill=&quot;Variable&quot;) vertical_tree ## Posterior estimates # Select desired support threshold support=0.9 negsupport=1-support # Basal tree postestimates_tree &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) #plotBeta(hM=m, post=getPostEstimate(hM=m, parName=&quot;Beta&quot;), param = &quot;Support&quot;, plotTree = TRUE, covNamesNumbers=c(1,0)) # Posterior estimate table post_beta &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome=factor(genome, levels=rev(postestimates_tree$tip.label))) %&gt;% mutate(value = case_when( value &gt;= support ~ &quot;Positive&quot;, value &lt;= negsupport ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% mutate(value=factor(value, levels=c(&quot;Positive&quot;,&quot;Neutral&quot;,&quot;Negative&quot;))) %&gt;% pivot_wider(names_from = variable, values_from = value) %&gt;% rename(intercept=2, Sc=3, index500=4, autumn=5, winter=6, logseqdepth=7, &quot;Sc:autumn&quot;=8, &quot;Sc:winter&quot;=9) %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(-intercept) #Phylums phylums &lt;- genome_metadata %&gt;% filter(genome %in% postestimates_tree$tip.label) %&gt;% arrange(match(genome, varpart_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) # Basal ggtree postestimates_tree &lt;- postestimates_tree %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultrametric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** #Add phylum colors next to the tree tips postestimates_tree &lt;- gheatmap(postestimates_tree, phylums, offset=-0.2, width=0.1, colnames=FALSE) + scale_fill_manual(values=custom_colors)+ labs(fill=&quot;Phylum&quot;) #Reset fill scale to use a different colour profile in the heatmap postestimates_tree &lt;- postestimates_tree + new_scale_fill() # Add posterior significant heatmap postestimates_tree &lt;- gheatmap(postestimates_tree, post_beta, offset=0, width=0.5, colnames=TRUE, colnames_position=&quot;top&quot;,colnames_angle=90, colnames_offset_y=1, hjust=0) + scale_fill_manual(values=c(&quot;#be3e2b&quot;,&quot;#f4f4f4&quot;,&quot;#b2b530&quot;))+ labs(fill=&quot;Trend&quot;) postestimates_tree + vexpand(.30, 1) # expand top 9.2 Model fit #NB: where does cv come from?? ask Ostaizka # MFCV &lt;- evaluateModelFit(hM=m, predY=cv) # # mean(MFCV$R2, na.rm = TRUE) # # genome_fit &lt;- tibble(genome=m$spNames, r2 = MFCV[[2]]) # # genome_counts_filt %&gt;% # mutate_if(is.numeric, ~ . / sum(.)) %&gt;% # left_join(genome_fit, by=&quot;genome&quot;) %&gt;% # filter(r2&gt;0.5) %&gt;% # select(-c(genome,r2)) %&gt;% # colSums() %&gt;% # hist() # # var_pred_table &lt;- tibble(mag=m$spNames, # pred=MFCV$R2, # var_pred=MFCV$R2 * varpart$vals[1,], # support=getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% .[2,], # estimate=getPostEstimate(hM=m, parName=&quot;Beta&quot;)$mean %&gt;% .[2,]) %&gt;% # mutate(enrichment=ifelse(support&gt;=support_threshold,&quot;Feral&quot;,&quot;Neutral&quot;)) %&gt;% # mutate(enrichment=ifelse(support&lt;=negsupport_threshold,&quot;Domestic&quot;,enrichment)) # # var_pred_table %&gt;% # ggplot(aes(x=estimate,y=var_pred, color=enrichment))+ # geom_point()+ # scale_color_manual(values=c(&quot;#bd70ae&quot;,&quot;#949293&quot;,&quot;#ebe8e8&quot;))+ # geom_hline(yintercept=0.005, linetype=&quot;dashed&quot;)+ # theme_minimal() # # predictive_mags &lt;- var_pred_table %&gt;% # filter(var_pred&gt;=0.005) %&gt;% # pull(mag) 9.3 Correlations among bacteria #Compute the residual correlation matrix OmegaCor = computeAssociations(m) # Reference tree (for sorting genomes) genome_tree_subset &lt;- genome_tree %&gt;% keep.tip(., tip=m$spNames) #Co-occurrence matrix at the animal level supportLevel = 0.95 toPlot = ((OmegaCor[[1]]$support&gt;supportLevel) + (OmegaCor[[1]]$support&lt;(1-supportLevel))&gt;0)*OmegaCor[[1]]$mean matrix &lt;- toPlot %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;genome1&quot;) %&gt;% pivot_longer(!genome1, names_to = &quot;genome2&quot;, values_to = &quot;cor&quot;) %&gt;% mutate(genome1= factor(genome1, levels=genome_tree_subset$tip.label)) %&gt;% mutate(genome2= factor(genome2, levels=genome_tree_subset$tip.label)) %&gt;% ggplot(aes(x = genome1, y = genome2, fill = cor)) + geom_tile() + scale_fill_gradient2(low = &quot;#be3e2b&quot;, mid = &quot;#f4f4f4&quot;, high = &quot;#b2b530&quot;)+ theme_void() + theme(legend.position = &quot;none&quot;) corr.legend &lt;- get_legend(matrix, position=&quot;right&quot;) corr.legend &lt;- as_ggplot(corr.legend) vtree &lt;- genome_tree_subset %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., expand=1.5) + hexpand(0.5) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultrametric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** #Add phylum colors next to the tree tips vtree &lt;- gheatmap(vtree, phylums, offset=-0.2, width=0.6, colnames=FALSE) + scale_fill_manual(values=custom_colors) + theme(legend.position = &#39;none&#39;) vtreeD &lt;- genome_tree_subset %&gt;% force.ultrametric(.,method=&quot;extend&quot;) %&gt;% ggtree(., expand=1.5, layout=&quot;dendrogram&quot;) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultrametric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** #Add phylum colors next to the tree tips vtreeD &lt;- gheatmap(vtreeD, phylums, offset=-0.2, width=0.8, colnames=FALSE) + scale_fill_manual(values=custom_colors) + theme(legend.position = &#39;none&#39;) #create composite figure grid.arrange(grobs = list(vtreeD,matrix,vtree,corr.legend), layout_matrix = rbind(c(5,5,1,1,1,1,1,1,1,1,1,5), c(5,5,1,1,1,1,1,1,1,1,1,5), c(5,5,1,1,1,1,1,1,1,1,1,5), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,4), c(3,3,2,2,2,2,2,2,2,2,2,4), c(3,3,2,2,2,2,2,2,2,2,2,4), c(3,3,2,2,2,2,2,2,2,2,2,4), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,5), c(3,3,2,2,2,2,2,2,2,2,2,5))) 9.4 Association with host species estimate &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$mean %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% filter(variable==&quot;speciesSciurus carolinensis&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;mean&quot;) %&gt;% dplyr::select(genome,mean) support &lt;- getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% filter(variable==&quot;speciesSciurus carolinensis&quot;) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;support&quot;) %&gt;% dplyr::select(genome,support) inner_join(estimate,support,by=join_by(genome==genome)) %&gt;% mutate(significance=ifelse(support &gt;= 0.9 | support &lt;= 0.1,1,0)) %&gt;% mutate(support=ifelse(mean&lt;0,1-support,support)) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% mutate(phylum = ifelse(support &gt; 0.9, phylum, NA)) %&gt;% ggplot(aes(x=mean,y=support,color=phylum))+ geom_point(alpha=0.7, shape=16, size=3)+ scale_color_manual(values = alpha(custom_colors, 0.7)) + geom_vline(xintercept = 0) + xlim(c(-2,2)) + labs(x = &quot;Beta regression coefficient&quot;, y = &quot;Posterior probability&quot;) + theme_minimal() 9.4.1 MAGs associated with S. carolinensis getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support_threshold ~ &quot;Positive&quot;, value &lt;= negsupport_threshold ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;speciesSciurus carolinensis&quot;, trend==&quot;Positive&quot;) %&gt;% arrange(-value) %&gt;% left_join(genome_metadata,by=join_by(genome==genome)) %&gt;% dplyr::select(genome,phylum,class,order,family,species,value) %&gt;% arrange(phylum, class, family, species)%&gt;% paged_table() 9.4.2 MAGs associated with S. vulgaris getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support_threshold ~ &quot;Positive&quot;, value &lt;= negsupport_threshold ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;speciesSciurus carolinensis&quot;, trend==&quot;Negative&quot;) %&gt;% arrange(-value) %&gt;% left_join(genome_metadata,by=join_by(genome==genome)) %&gt;% dplyr::select(genome,phylum,class,order,family,species,value) %&gt;% arrange(phylum, class, family, species)%&gt;% paged_table() 9.5 Microbiome composition predictions 9.5.1 Predicted composition by species # Overall species prediction pred_species &lt;- constructGradient(m, focalVariable = &quot;species&quot;, non.focalVariables = list(logseqdepth=list(1),index500=list(1), season=list(1)), ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) %&gt;% as.data.frame() %&gt;% mutate(species=c(&quot;Sciurus vulgaris&quot;,&quot;Sciurus carolinensis&quot;)) %&gt;% pivot_longer(!species, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(genome = sub(&quot;(.*\\\\..*\\\\.)[^.]+.*&quot;, &quot;\\\\1&quot;, genome)) %&gt;% #remove iteration suffix mutate(genome = sub(&quot;\\\\.$&quot;, &quot;&quot;, genome)) # levels(m$XData$species) # levels(m$XData$season) pred_species %&gt;% pivot_wider(names_from = species, values_from = value) %&gt;% unnest(c(`Sciurus carolinensis`, `Sciurus vulgaris`)) %&gt;% mutate(diff.grey_red = `Sciurus carolinensis` - `Sciurus vulgaris`) %&gt;% select(genome, diff.grey_red) %&gt;% left_join(genome_metadata, by=join_by(genome==genome)) %&gt;% mutate(genome= factor(genome, levels=genome_tree_subset$tip.label)) %&gt;% ggplot(., aes(y=genome, x=diff.grey_red, fill=phylum, color=phylum)) + scale_color_manual(values=custom_colors)+ geom_vline(xintercept = 0)+ scale_fill_manual(values=alpha(custom_colors,0.3))+ geom_boxplot(outlier.shape = NA) + theme_classic() + theme(axis.text.y = element_blank()) Support values of the host species variable per genome are interpreted as enrichment for either red (S. vulgaris) or grey squirrels (S. carolinensis) The most likely microbiome compositions of red (S. vulgaris) and grey squirrels (S. carolinensis) as predicted by the hmsc model Log-abundance differences between Sciurus vulgaris and S. carolinensis for genera found enriched in either species. 9.5.2 Predicted composition by urbanization gradient = seq(0,1, by=0.1) gradientlength = length(gradient) pred_urban &lt;- constructGradient(m, focalVariable = &quot;index500&quot;, non.focalVariables = list(logseqdepth=list(1),species=list(1), season=list(1)), ngrid=gradientlength) %&gt;% predict(m, Gradient = ., expected = TRUE) %&gt;% do.call(rbind,.) %&gt;% as.data.frame() %&gt;% mutate(index500=rep(gradient,1000)) %&gt;% pivot_longer(-c(index500), names_to = &quot;genome&quot;, values_to = &quot;value&quot;) getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% as.data.frame() %&gt;% mutate(variable=m$covNames) %&gt;% pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% mutate(trend = case_when( value &gt;= support_threshold ~ &quot;Positive&quot;, value &lt;= negsupport_threshold ~ &quot;Negative&quot;, TRUE ~ &quot;Neutral&quot;)) %&gt;% filter(variable==&quot;index500&quot;) %&gt;% select(genome,trend) %&gt;% left_join(pred_urban, by=join_by(genome==genome)) %&gt;% group_by(genome, trend, index500) %&gt;% summarize(value = mean(value, na.rm = TRUE)) %&gt;% left_join(genome_metadata, by=join_by(genome == genome)) %&gt;% ggplot(aes(x=index500, y=value, group=genome, color=phylum, linetype=trend)) + geom_line() + scale_linetype_manual(values=c(&quot;solid&quot;,&quot;dashed&quot;,&quot;solid&quot;)) + scale_color_manual(values=custom_colors) + facet_grid(fct_rev(trend) ~ phylum) + labs(y=&quot;Genome abundance (log)&quot;,x=&quot;Urbanization index&quot;) + theme(legend.position = &quot;none&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 0.8,), axis.line.x = element_line(size = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), strip.text.x = element_text(angle = 90, hjust = 0,) ) 9.5.3 Predicted composition by season # pred_season_Sc &lt;- constructGradient(m, # focalVariable = &quot;season&quot;, # non.focalVariables = list(logseqdepth=list(1),species=list(3, &quot;Sciurus carolinensis&quot;), index500=list(1)), # ngrid=gradientlength) %&gt;% # predict(m, Gradient = ., expected = TRUE) %&gt;% # as.data.frame() %&gt;% # mutate(season=c(&quot;spring-summer&quot;,&quot;autumn&quot;,&quot;winter&quot;)) %&gt;% # pivot_longer(!season, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) # # getPostEstimate(hM=m, parName=&quot;Beta&quot;)$support %&gt;% # as.data.frame() %&gt;% # mutate(variable=m$covNames) %&gt;% # pivot_longer(!variable, names_to = &quot;genome&quot;, values_to = &quot;value&quot;) %&gt;% # mutate(trend = case_when( # value &gt;= support_threshold ~ &quot;Positive&quot;, # value &lt;= negsupport_threshold ~ &quot;Negative&quot;, # TRUE ~ &quot;Neutral&quot;)) %&gt;% # filter(variable %in% c(&quot;seasonspring-summer&quot;, &quot;seasonautumn&quot;, &quot;seasonwinter&quot;)) %&gt;% # select(genome,trend) %&gt;% # left_join(pred_season_Sc, by=join_by(genome==genome)) %&gt;% # group_by(genome, trend, season) %&gt;% # summarize(value = mean(value, na.rm = TRUE)) %&gt;% # left_join(genome_metadata, by=join_by(genome == genome)) %&gt;% # ggplot(aes(x=season, y=value, group=genome, color=phylum, linetype=trend)) + # geom_boxplot(outlier.shape = NA) + # scale_color_manual(values=custom_colors) + # facet_grid(fct_rev(trend) ~ phylum) + # labs(y=&quot;Genome abundance (log)&quot;,x=&quot;Season&quot;) + # theme(legend.position = &quot;none&quot;) + # theme_minimal() + # theme(legend.position = &quot;none&quot;, # axis.text.x = element_text(angle = 45, hjust = 0.8,), # axis.line.x = element_line(size = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), # strip.text.x = element_text(angle = 90, hjust = 0,) # ) # # pred_season %&gt;% # mutate(genome= factor(genome, levels=genome_tree_subset$tip.label)) %&gt;% # group_by(genome, season) %&gt;% # summarize(value = mean(value, na.rm = TRUE)) %&gt;% # left_join(genome_metadata, by=join_by(genome==genome)) %&gt;% # filter(!is.na(phylum)) %&gt;% # ggplot(., aes(y=value, x=genome, group=phylum, color=phylum, fill=phylum)) + # facet_grid( . ~ season) + # scale_color_manual(values=custom_colors)+ # scale_fill_manual(values=alpha(custom_colors,0.3))+ # geom_boxplot(outlier.shape = NA) + # theme_classic() + # theme(axis.text.y = element_blank(), # axis.text.x = element_blank()) 9.6 Microbiome functional predictions tss &lt;- function(abund){sweep(abund, 2, colSums(abund), FUN=&quot;/&quot;)} genome_counts &lt;- genome_counts %&gt;% column_to_rownames(var=&quot;genome&quot;) genome_kegg &lt;- genome_kegg %&gt;% column_to_rownames(var=&quot;genome&quot;) genome_gifts &lt;- genome_gifts %&gt;% column_to_rownames(var=&quot;genome&quot;) #Get list of present MAGs present_MAGs &lt;- genome_counts %&gt;% filter(rownames(.) %in% m$spNames) %&gt;% rownames() #Align distillr annotations with present MAGs and remove all-zero and all-one traits present_MAGs &lt;- present_MAGs[present_MAGs %in% rownames(genome_gifts)] GIFTs_elements &lt;- genome_gifts[present_MAGs,] %&gt;% select_if(~!all(. == 0)) %&gt;% #remove all-zero modules select_if(~!all(. == 1)) #remove all-one modules #Aggregate element-level GIFTs into the function level GIFTs_functions &lt;- to.functions(GIFTs_elements,GIFT_db) #Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs and get overall metabolic capacity indices per MAG (at the domain level) GIFTs_domains &lt;- to.domains(GIFTs_functions,GIFT_db) %&gt;% as.data.frame() %&gt;% mutate(Overall=rowMeans(select(.,Biosynthesis,Structure,Degradation), na.rm=TRUE)) 9.6.1 Function-level predictions 9.6.1.1 Predicted functions by species community_func_sp &lt;- pred_sp %&gt;% filter(genome %in% present_MAGs) %&gt;% #keep only predictive mags -&gt; NB: I can&#39;t get predictive mags rn (see Model fit) group_by(species, genome) %&gt;% mutate(row_id = row_number()) %&gt;% pivot_wider(names_from = genome, values_from = value) %&gt;% ungroup() %&gt;% group_split(row_id) %&gt;% as.list() %&gt;% lapply(., FUN = function(x){x %&gt;% dplyr::select(-row_id) %&gt;% column_to_rownames(var = &quot;species&quot;) %&gt;% as.data.frame() %&gt;% exp() %&gt;% t() %&gt;% tss() %&gt;% to.community(GIFTs_functions,.,GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;species&quot;) }) function_pred_sp &lt;- map_dfr(community_func_sp, function(df) { Sc_values &lt;- df %&gt;% filter(species == &quot;Sciurus carolinensis&quot;) %&gt;% select(-species) Sv_values &lt;- df %&gt;% filter(species == &quot;Sciurus vulgaris&quot;) %&gt;% select(-species) Sc_values - Sv_values }) %&gt;% mutate(iteration=c(1:1000)) %&gt;% pivot_longer(!iteration,names_to=&quot;trait&quot;,values_to=&quot;value&quot;) %&gt;% group_by(trait) %&gt;% summarise(mean=mean(value), p1 = quantile(value, probs = 0.1), p9 = quantile(value, probs = 0.9), positive_support = sum(value &gt; 0)/1000, negative_support = sum(value &lt; 0)/1000) %&gt;% arrange(-positive_support) # Positively associated function_pred_sp %&gt;% filter(mean &gt;0) %&gt;% arrange(-positive_support) %&gt;% filter(positive_support&gt;=0.9) %&gt;% paged_table() # Negatively associated function_pred_sp %&gt;% filter(mean &lt;0) %&gt;% arrange(-negative_support) %&gt;% filter(negative_support&gt;=0.9) %&gt;% paged_table() positive &lt;- function_pred_sp %&gt;% filter(mean &gt;0) %&gt;% arrange(mean) %&gt;% filter(positive_support&gt;=0.9) %&gt;% dplyr::select(-negative_support) %&gt;% rename(support=positive_support) negative &lt;- function_pred_sp %&gt;% filter(mean &lt;0) %&gt;% arrange(mean) %&gt;% filter(negative_support&gt;=0.9) %&gt;% dplyr::select(-positive_support) %&gt;% rename(support=negative_support) all_functions &lt;- function_pred_sp %&gt;% left_join(GIFT_db,by=join_by(trait==Code_function)) %&gt;% mutate(trait=factor(trait)) %&gt;% mutate(function_legend=str_c(trait,&quot; - &quot;,Function)) %&gt;% select(trait,mean,p1,p9,function_legend) %&gt;% unique() gift_colors &lt;- gift_colors %&gt;% mutate(legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% filter(legend %in% all_functions$function_legend) all_functions %&gt;% ggplot(aes(x=mean, y=fct_reorder(function_legend, mean), xmin=p1, xmax=p9, color=function_legend)) + geom_point() + geom_errorbar() + #xlim(c(-0.12,0.05)) + geom_vline(xintercept=0) + scale_color_manual(values = gift_colors$Color) + theme_minimal() + labs(x=&quot;Regression coefficient&quot;,y=&quot;Functional trait&quot;) + #guides(col = guide_legend(ncol = 1)) theme(legend.position = &quot;none&quot;) 9.6.1.2 Predicted functions by urbanization community_func_urb &lt;- pred_urban %&gt;% group_by(index500, genome) %&gt;% mutate(row_id = row_number()) %&gt;% pivot_wider(names_from = genome, values_from = value) %&gt;% ungroup() %&gt;% group_split(row_id) %&gt;% as.list() %&gt;% lapply(., FUN = function(x){x %&gt;% select(-row_id) %&gt;% column_to_rownames(var = &quot;index500&quot;) %&gt;% as.data.frame() %&gt;% exp() %&gt;% t() %&gt;% tss() %&gt;% to.community(GIFTs_functions,.,GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;index500&quot;) }) calculate_slope &lt;- function(x) { lm_fit &lt;- lm(unlist(x) ~ seq_along(unlist(x))) coef(lm_fit)[2] } function_pred_urb &lt;- map_dfc(community_func_urb, function(mat) { mat %&gt;% column_to_rownames(var = &quot;index500&quot;) %&gt;% t() %&gt;% as.data.frame() %&gt;% rowwise() %&gt;% mutate(slope = calculate_slope(c_across(everything()))) %&gt;% select(slope) }) %&gt;% t() %&gt;% as.data.frame() %&gt;% set_names(colnames(community_func_urb[[1]])[-1]) %&gt;% rownames_to_column(var=&quot;iteration&quot;) %&gt;% pivot_longer(!iteration, names_to=&quot;trait&quot;,values_to=&quot;value&quot;) %&gt;% group_by(trait) %&gt;% summarise(mean=mean(value), p1 = quantile(value, probs = 0.1), p9 = quantile(value, probs = 0.9), positive_support = sum(value &gt; 0)/1000, negative_support = sum(value &lt; 0)/1000) %&gt;% arrange(-positive_support) # Positively associated function_pred_urb %&gt;% filter(mean &gt;0) %&gt;% arrange(-positive_support) %&gt;% filter(positive_support&gt;=0.9) %&gt;% paged_table() #Negatively associated function_pred_urb %&gt;% filter(mean &lt;0) %&gt;% arrange(-negative_support) %&gt;% filter(negative_support&gt;=0.9) %&gt;% paged_table() #Positively associated positive &lt;- function_pred_urb%&gt;% filter(mean &gt;0) %&gt;% arrange(mean) %&gt;% filter(positive_support&gt;=0.9) %&gt;% select(-negative_support) %&gt;% rename(support=positive_support) #Negatively associated negative &lt;- function_pred_urb %&gt;% filter(mean &lt;0) %&gt;% arrange(mean) %&gt;% filter(negative_support&gt;=0.9) %&gt;% select(-positive_support) %&gt;% rename(support=negative_support) all_functions &lt;- function_pred_urb %&gt;% left_join(GIFT_db,by=join_by(trait==Code_function)) %&gt;% mutate(trait=factor(trait)) %&gt;% mutate(function_legend=str_c(trait,&quot; - &quot;,Function)) %&gt;% select(trait,mean,p1,p9,function_legend) %&gt;% unique() gift_colors &lt;- read_tsv(&quot;data/gift_colors.tsv&quot;) %&gt;% mutate(legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% filter(legend %in% all_functions$function_legend) all_functions %&gt;% ggplot(aes(x=mean, y=fct_reorder(function_legend, mean), xmin=p1, xmax=p9, color=function_legend)) + geom_point() + geom_errorbar() + xlim(c(-0.017,0.017)) + geom_vline(xintercept=0) + scale_color_manual(values = gift_colors$Color) + theme_minimal() + labs(x=&quot;Regression coefficient&quot;,y=&quot;Functional trait&quot;) + guides(col = guide_legend(ncol = 1)) # all_functions &lt;- bind_rows(positive,negative) %&gt;% # left_join(GIFT_db,by=join_by(trait==Code_function)) %&gt;% # mutate(trait=factor(trait,levels=c(rev(positive$trait),rev(negative$trait)))) %&gt;% # mutate(Code_function=factor(Code_function)) %&gt;% # mutate(function_legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% # select(trait,mean,p1,p9,function_legend) %&gt;% # unique() # # gift_colors &lt;- gift_colors %&gt;% # mutate(legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% # filter(legend %in% all_elements$function_legend) # # all_functions %&gt;% # ggplot(aes(x=mean, y=fct_reorder(function_legend, mean), xmin=p1, xmax=p9, color=function_legend)) + # geom_point() + # geom_errorbar() + # #xlim(c(-0.05,0.05)) + # geom_vline(xintercept=0) + # scale_color_manual(values = gift_colors$Color) + # theme_minimal() + # labs(x=&quot;Regression coefficient&quot;,y=&quot;Functional trait&quot;) community_func_urb %&gt;% bind_rows() %&gt;% pivot_longer(-index500, names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% filter(trait %in% c(positive$trait, negative$trait)) %&gt;% mutate(trait=factor(trait, levels=c(positive$trait, negative$trait))) %&gt;% mutate(index500=as.numeric(index500)) %&gt;% ggplot(aes(x=index500, y=value)) + geom_smooth(method = lm, formula = y ~ x, se = TRUE) + #geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE) + facet_wrap(~trait, ncol=5, scales=&quot;free&quot;) + theme_minimal() + labs(x=&quot;Urbanization&quot;,y=&quot;Metabolic Capacity Index&quot;) 9.6.1.3 Predicted elements by season S. carolinensis S. vulgaris 9.6.2 Element-level predictions 9.6.2.1 Predicted elements by species community_elem_sp &lt;- pred_sp %&gt;% group_by(species, genome) %&gt;% mutate(row_id = row_number()) %&gt;% pivot_wider(names_from = genome, values_from = value) %&gt;% ungroup() %&gt;% group_split(row_id) %&gt;% as.list() %&gt;% lapply(., FUN = function(x){x %&gt;% select(-row_id) %&gt;% column_to_rownames(var = &quot;species&quot;) %&gt;% as.data.frame() %&gt;% exp() %&gt;% t() %&gt;% tss() %&gt;% to.community(GIFTs_elements,.,GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;species&quot;) }) element_pred_sp &lt;- map_dfr(community_elem_sp, function(df) { Sc_values &lt;- df %&gt;% filter(species == &quot;Sciurus carolinensis&quot;) %&gt;% select(-species) Sv_values &lt;- df %&gt;% filter(species == &quot;Sciurus vulgaris&quot;) %&gt;% select(-species) Sc_values - Sv_values }) %&gt;% mutate(iteration=c(1:1000)) %&gt;% pivot_longer(!iteration,names_to=&quot;trait&quot;,values_to=&quot;value&quot;) %&gt;% group_by(trait) %&gt;% summarise(mean=mean(value), p1 = quantile(value, probs = 0.1), p9 = quantile(value, probs = 0.9), positive_support = sum(value &gt; 0)/1000, negative_support = sum(value &lt; 0)/1000) %&gt;% arrange(-positive_support) # Positively associated element_pred_sp %&gt;% filter(mean &gt;0) %&gt;% arrange(-positive_support) %&gt;% filter(positive_support&gt;=0.9) %&gt;% paged_table() # Negatively associated element_pred_sp %&gt;% filter(mean &lt;0) %&gt;% arrange(-negative_support) %&gt;% filter(negative_support&gt;=0.9) %&gt;% paged_table() positive &lt;- element_pred_sp %&gt;% filter(mean &gt;0) %&gt;% arrange(mean) %&gt;% filter(positive_support&gt;=0.9) %&gt;% dplyr::select(-negative_support) %&gt;% rename(support=positive_support) negative &lt;- element_pred_sp %&gt;% filter(mean &lt;0) %&gt;% arrange(mean) %&gt;% filter(negative_support&gt;=0.9) %&gt;% dplyr::select(-positive_support) %&gt;% rename(support=negative_support) all_elements &lt;- bind_rows(positive,negative) %&gt;% left_join(GIFT_db,by=join_by(trait==Code_element)) %&gt;% mutate(trait=factor(trait,levels=c(rev(positive$trait),rev(negative$trait)))) %&gt;% mutate(Code_function=factor(Code_function)) %&gt;% mutate(element_legend=str_c(trait,&quot; - &quot;,Element)) %&gt;% mutate(function_legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% select(trait,mean,p1,p9,element_legend,function_legend) %&gt;% unique() gift_colors &lt;- read_tsv(&quot;data/gift_colors.tsv&quot;) %&gt;% mutate(legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% filter(legend %in% all_elements$function_legend) all_elements %&gt;% ggplot(aes(x=mean, y=fct_reorder(element_legend, mean), xmin=p1, xmax=p9, color=function_legend)) + geom_point() + geom_errorbar() + #xlim(c(-0.05,0.05)) + geom_vline(xintercept=0) + scale_color_manual(values = gift_colors$Color) + theme_minimal() + labs(x=&quot;Regression coefficient&quot;,y=&quot;Functional trait&quot;) 9.6.2.2 Predicted elements by urbanization community_elem_urb &lt;- pred_urban %&gt;% group_by(index500, genome) %&gt;% mutate(row_id = row_number()) %&gt;% pivot_wider(names_from = genome, values_from = value) %&gt;% ungroup() %&gt;% group_split(row_id) %&gt;% as.list() %&gt;% lapply(., FUN = function(x){x %&gt;% select(-row_id) %&gt;% column_to_rownames(var = &quot;index500&quot;) %&gt;% as.data.frame() %&gt;% exp() %&gt;% t() %&gt;% tss() %&gt;% to.community(GIFTs_elements,.,GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;index500&quot;) }) calculate_slope &lt;- function(x) { lm_fit &lt;- lm(unlist(x) ~ seq_along(unlist(x))) coef(lm_fit)[2] } element_pred_urb &lt;- map_dfc(community_elem_urb, function(mat) { mat %&gt;% column_to_rownames(var = &quot;index500&quot;) %&gt;% t() %&gt;% as.data.frame() %&gt;% rowwise() %&gt;% mutate(slope = calculate_slope(c_across(everything()))) %&gt;% select(slope) }) %&gt;% t() %&gt;% as.data.frame() %&gt;% set_names(colnames(community_elem_urb[[1]])[-1]) %&gt;% rownames_to_column(var=&quot;iteration&quot;) %&gt;% pivot_longer(!iteration, names_to=&quot;trait&quot;,values_to=&quot;value&quot;) %&gt;% group_by(trait) %&gt;% summarise(mean=mean(value), p1 = quantile(value, probs = 0.1), p9 = quantile(value, probs = 0.9), positive_support = sum(value &gt; 0)/1000, negative_support = sum(value &lt; 0)/1000) %&gt;% arrange(-positive_support) # Positively associated element_pred_urb %&gt;% filter(mean &gt;0) %&gt;% arrange(-positive_support) %&gt;% filter(positive_support&gt;=0.9) %&gt;% paged_table() #Negatively associated element_pred_urb %&gt;% filter(mean &lt;0) %&gt;% arrange(-negative_support) %&gt;% filter(negative_support&gt;=0.9) %&gt;% paged_table() #Positively associated positive &lt;- element_pred_urb%&gt;% filter(mean &gt;0) %&gt;% arrange(mean) %&gt;% filter(positive_support&gt;=0.9) %&gt;% select(-negative_support) %&gt;% rename(support=positive_support) #Negatively associated negative &lt;- element_pred_urb %&gt;% filter(mean &lt;0) %&gt;% arrange(mean) %&gt;% filter(negative_support&gt;=0.9) %&gt;% select(-positive_support) %&gt;% rename(support=negative_support) all_elements &lt;- bind_rows(positive,negative) %&gt;% left_join(GIFT_db,by=join_by(trait==Code_element)) %&gt;% mutate(trait=factor(trait,levels=c(rev(positive$trait),rev(negative$trait)))) %&gt;% mutate(Code_function=factor(Code_function)) %&gt;% mutate(element_legend=str_c(trait,&quot; - &quot;,Element)) %&gt;% mutate(function_legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% select(trait,mean,p1,p9,element_legend,function_legend) %&gt;% unique() gift_colors &lt;- gift_colors %&gt;% mutate(legend=str_c(Code_function,&quot; - &quot;,Function)) %&gt;% filter(legend %in% all_elements$function_legend) all_elements %&gt;% ggplot(aes(x=mean, y=fct_reorder(element_legend, mean), xmin=p1, xmax=p9, color=function_legend)) + geom_point() + geom_errorbar() + #xlim(c(-0.05,0.05)) + geom_vline(xintercept=0) + scale_color_manual(values = gift_colors$Color) + theme_minimal() + labs(x=&quot;Regression coefficient&quot;,y=&quot;Functional trait&quot;) community_elem_urb %&gt;% bind_rows() %&gt;% pivot_longer(-index500, names_to = &quot;trait&quot;, values_to = &quot;value&quot;) %&gt;% filter(trait %in% c(positive$trait, negative$trait)) %&gt;% mutate(trait=factor(trait, levels=c(positive$trait, negative$trait))) %&gt;% mutate(index500=as.numeric(index500)) %&gt;% ggplot(aes(x=index500, y=value)) + geom_smooth(method = lm, formula = y ~ x, se = TRUE) + #geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = TRUE) + facet_wrap(~trait, ncol=6, scales=&quot;free&quot;) + theme_minimal() + labs(x=&quot;Urbanization&quot;,y=&quot;Metabolic Capacity Index&quot;) 9.6.2.3 Predicted elements by season S. carolinensis S. vulgaris "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
